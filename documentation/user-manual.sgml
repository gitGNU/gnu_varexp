<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY version SYSTEM "../VERSION">
<!ENTITY varexp "<application>libvarexp</application>">
<!ENTITY unescape "<function>unescape</function>">
<!ENTITY expand "<function>expand</function>">
<!ENTITY sh "<citerefentry><refentrytitle>sh</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY make "<citerefentry><refentrytitle>make</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY perl "<citerefentry><refentrytitle>perl</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY tr "<citerefentry><refentrytitle>tr</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY sed "<citerefentry><refentrytitle>sed</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY tolower "<citerefentry><refentrytitle>tolower</refentrytitle><manvolnum>3</manvolnum></citerefentry>">
<!ENTITY toupper "<citerefentry><refentrytitle>toupper</refentrytitle><manvolnum>3</manvolnum></citerefentry>">
]>

<article lang="en">
  <articleinfo>
    <title>Variable Expression Library &version;</title>
    <author>
      <firstname>Peter</firstname>
      <surname>Simons</surname>
      <affiliation>
        <address><email>simons@computer.org</email></address>
      </affiliation>
    </author>
  </articleinfo>

  <sect1>
    <title>Purpose of this Library</title>

    <para>&varexp; is a C++ library that allows its users to detach any kind of
information from the representation of that information by providing a
simple-to-use but powerful text-template mechanism. Similar mechanisms have been
available in tools like &sh;, &make;, or &perl; forever and have proven to be
very useful. The basic idea is that the relevant information is made available
in variables, which the author of the template can than use within the text
itself as he or she sees fit.</para>

    <para>Consider, for example, a tool that will calculate the monthly
financial reports of a small company. Such a program should only
<emphasis>calculate</emphasis> the required values, it should not worry about
writing the resulting reports into an HTML file, a CSV file, or whatever format
is desired. Instead, it should make the results of the calculation available in
the variables <quote>$TURNOVER</quote>, <quote>$PROFIT</quote>, and
<quote>$INCREASE</quote>. Then, using &varexp;, it could load an arbitrary
template file and have the actual values inserted at the apropriate positions.
Without changing a single line of code, one could generate the monthly report in
HTML:</para>

    <informalexample>
      <screen>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Financial Report&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;h1&gt;Financial report&lt;/h1&gt;

    &lt;p&gt;This month, our glorious company reached a
total turnover of ${TOTAL} Euros, totalling ${PROFIT}
Euros before taxes. That means we have increased our
profit by ${INCREASE} percent compared to last
month.&lt;/p&gt;

  &lt;/body&gt;
&lt;/html&gt;</screen>
    </informalexample>

    <para>Or you can send it out as a plain-text e-mail:</para>

    <informalexample>
      <screen>From: nobody@example.org (Monthly Financial Data)
Subject: This month's financial report

Dear Colleagues,

we have earned a total of ${PROFIT} Euros this month!
This means that we have increased profits by ${PROFIT}
percent compared to last month, totalling a turnover
of ${TURNOVER} of Euros.

Sincerely yours,
    The Statistics Program</screen>
    </informalexample>

    <para>Even better, by using such templates to generate the output you are
effectively independent of the language you choose! The last report, for
example, could also read:</para>

    <informalexample>
      <screen>From: nobody@example.org (Grssss&ouml;tmpf!)
Subject: Ajahaha Mzoodeutschmark

Nuwarskvu,

Quhu&szlig;aour Maou Ahosetuh Cravullitstziki Nakaou ${PROFIT}
Akqiss&auml;e&uuml;&szlig; Blaga: ${TURNOVER} Stauhr ${INCREASE}!!!!</screen>
    </informalexample>

    <para>This version is -- as you can probably easily recognize -- in
German.</para>

    <para>&varexp; offers application developers two functions, that will do all
this for them, plus, the end-user has <emphasis>numerous</emphasis> ways not
only to insert variables into his template files but to modify the variables
contents on the fly, do full-blown regular expression search-and-replaces, or
loop over the contents of arrays of variables.</para>

    <para>Furthermore, the parser included in &varexp; can be re-configured to
use tokens different from the ones shown in the examples; one could as well use
<quote>%{NAME}</quote>, change the set of allowed characters for variable names,
etc.</para>

    <para>And last but certainly not least, these variables are not limited to
<quote>environment variables</quote> at all. The programmer is free to provide a
callback function to &varexp; that will be used to map a variable name to its
contents. Thus, the variables your application provides, can reside internally
completely. In fact, they can reside pretty much anywhere you want and they
contain pretty much anything you want, as long as <emphasis>you</emphasis> write
the callback.</para>

  </sect1>

  <sect1>
    <title>Expressions Supported by the Library</title>

    <sect2>
      <title>Variable Expressions</title>

      <para>&varexp; distinguishes variables into simple and complex
expressions. A simple expression has the form <quote>$NAME</quote> and will
basically only replace the variable in the text buffer with its contents.
Complex expressions have the form
<quote>${NAME:operation1:operation2:&hellip;}</quote> and may perform various
operations on the variable's contents before inserting it into the text
buffer.</para>

      <para>Please note that due to the way simple expressions are parsed, it
may not always be possible to use the simple-expression form even though you do
not want to perform any operations. If your input text was <quote>This is a
$FOObar</quote>, but the last <quote>bar</quote> part is meant to be a literal
string, you'd have use <quote>This is a ${FOO}bar</quote>, because the parser
will interpret any valid variable-name character following the dollar as part of
the variable name; it will not recognize that <quote>$FOO</quote> would exist
while <quote>$FOObar</quote> would not.</para>

      <para>Also, &varexp; does not distinguish case in any way. For the
library, <quote>$FoObAr</quote> and <quote>$fOoBaR</quote> are just strings --
whether they refer to the same variable or not is entirely up to the application
that provides the callback used to resolve variables to their contents.</para>

      <para>If you want to enter a text like <quote>$foo</quote> literally,
you'll have to escape the <quote>$</quote> sign by prefacing it with a
backslash: <quote>\$foo</quote>. Then &varexp; won't interpret this expression
as a variable.</para>
    </sect2>

    <sect2>
      <title>Operations on Variables</title>

      <para>In addition to just inserting the variable's contents into the
buffer, you can use various operations to modify its contents before the
expression is expanded. Such operations are used by appending a colon plus the
apropriate command character to the variable name in complex expression, for
example: <quote>${FOOBAR:l}</quote>. Furthermore, you can chain any number of
operations simply by appending another command to the last one:
<quote>${FOOBAR:l:u:l:u:&hellip;}</quote>.</para>

      <para>The supported operations are:</para>

      <variablelist>
        <varlistentry>
          <term><literal>${NAME:#}</literal></term>
          <listitem>
            <para>This operation will expand the expression to the length of the
contents of <literal>$NAME</literal>. If, for example, <literal>$FOO</literal>
is <quote>foobar</quote>, then <literal>${FOO:#}</literal> will result in
<quote>6</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:l}</literal></term>
          <listitem>
            <para>This operation will turn the contents of
<literal>$NAME</literal> to all lower-case, using the system routine
&tolower;.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:u}</literal></term>
          <listitem>
            <para>This operation will turn the contents of
<literal>$NAME</literal> to all upper-case, using the system routine
&toupper;.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:*<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is empty. If <literal>$NAME</literal> is not empty,
it will expand to an empty string.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:*${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:-<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is empty. If <literal>$NAME</literal> is not empty,
it will evaluate to the <literal>$NAME</literal>'s contents.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:-${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:+<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is not empty. If <literal>$NAME</literal> is empty,
it will expand to an empty string.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:+${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to a part of
<literal>$NAME</literal>'s contents, which starts at
<replaceable>start</replaceable> and ends at <replaceable>end</replaceable>.
Both parameters <replaceable>start</replaceable> and
<replaceable>end</replaceable> are unsigned numbers.</para>

            <para>Please note that the character at position
<replaceable>end</replaceable> is <emphasis>included</emphasis> in the result;
<quote>${FOOBAR:o3,4}</quote>, for instance, will return a two-character string.
Also, please note that start positions begin at zero (0)!</para>

            <para>If the <replaceable>end</replaceable> parameter is not
specified, as in <quote>${FOOBAR:o3,}</quote>, the operation will return the
string starting from position 3 to the end of the string.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:o<replaceable>start</replaceable>-<replaceable>length</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to a part of
<literal>$NAME</literal>'s contents, which starts at
<replaceable>start</replaceable> and ends at
<quote><replaceable>start</replaceable>+<replaceable>length</replaceable></quote>.
Both parameters <replaceable>start</replaceable> and
<replaceable>end</replaceable> are unsigned numbers.</para>

            <para><quote>${FOOBAR:o3-4}</quote>, for example, means to return
the next 4 charaters starting at position 3 in the string. Please note that
start positions begin at zero (0)!</para>

            <para>If the <replaceable>end</replaceable> parameter is left out,
as in <quote>${FOOBAR:o3-}</quote>, the operation will return the string from
position 3 to the end.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:s/<replaceable>pattern</replaceable>/<replaceable>string</replaceable>/<replaceable>gti</replaceable>}</literal></term>
          <listitem>
            <para>This operation will perform a search-and-replace operation on
the contents of <literal>$NAME</literal> and return the result. The behavior of
the search-and-replace may be modified by the following flags: If a
<literal>t</literal> flag has been provided, a plain text search-and-replace is
performed, otherwise, the default is to do a regular expression
search-and-replace as in the system utility &sed;. If the <literal>g</literal>
flag has been provided, the search-and-replace will replace
<emphasis>all</emphasis> instances of <replaceable>pattern</replaceable> by
<replaceable>replace</replaceable>, instead of replacing only the first instance
(the default). If the <literal>i</literal> flag has been provided, the
search-and-replace will take place case-insensitively, otherwise, the default is
to search case-sensitively.</para>

            <para>The parameters <replaceable>pattern</replaceable> and
<replaceable>replace</replaceable> can be an arbitrary text. In particular, they
may contain other variables or even complex variable expressions, for example:
<quote>${FOO:s/${BAR:u}/$FOO/ti}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:y/<replaceable>ochars</replaceable>/<replaceable>nchars</replaceable>/}</literal></term>
          <listitem>
            <para>This operation will translate all characters in the contents
of <literal>$NAME</literal> that are found in the
<replaceable>ochars</replaceable> class to the corresponding character in the
<replaceable>nchars</replaceable> class -- just like the system utility &tr;
does. Both <replaceable>ochars</replaceable> and
<replaceable>nchars</replaceable> may contain character range specifications,
for example <quote>a-z0-9</quote>. A hyphon as the first or last character of
the class specification is interpreted literally. Both the
<replaceable>ochars</replaceable> and the <replaceable>nchars</replaceable>
class must contain the same number of characters after all ranges are expanded,
or an error is returned.

          <para>If, for example, <quote>$FOO</quote> contains
<quote>foobar</quote>, then <quote>${FOO:y/a-z/A-Z/}</quote> would yield
<quote>FOOBAR</quote>. Another goodie is to use that operation to ROT13-encrypt
or decrypt a string with the expression
<quote>${FOO:y/a-z/n-za-m/}</quote>.</para>

            <para>The parameters <replaceable>ochars</replaceable> and
<replaceable>nchars</replaceable> can be an arbitrary text. In particular, they
may contain other variables or even complex variable expressions, for example:
<quote>${FOO:y/${BAR:u}/$TEST/}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:p/<replaceable>width</replaceable>/<replaceable>string</replaceable>/<replaceable>align</replaceable>}</literal></term>
          <listitem>
            <para>This operation will pad the contents of
<literal>$NAME</literal> with <replaceable>string</replaceable> according to the
<replaceable>align</replaceable> parameter, so that the result is at least
<replaceable>width</replaceable> characters long. Valid parameters for align are
<literal>l</literal> (left), <literal>r</literal> (right), or
<literal>c</literal> (center). The <replaceable>string</replaceable> parameter
may contain multiple characters, if you see any use for that.</para>

            <para>If, for example, <quote>$FOO</quote> is <quote>foobar</quote>,
then <quote>${FOO:p/20/./c}</quote> would yield
<quote>.......foobar.......</quote>; <quote>${FOO:p/20/./l}</quote> would yield
<quote>foobar..............</quote>; and <quote>${FOO:p/20/./r}</quote> would
yield <quote>..............foobar</quote>;</para>

            <para>The parameter <replaceable>string</replaceable> can be an
arbitrary text. In particular, it may contain other variables or even complex
variable expressions, for example: <quote>${FOO:p/20/${BAR}/r/}</quote>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Quoted Pairs</title>

      <para>In addition to the variable expressions discussed in the previous
sections, &varexp; can also be used to expand so called <quote>quoted
pairs</quote> in the text. Quoted pairs are well-known from programming
languages like C, for example. A quoted pair consists of the backslash followed
by another character, for example: <quote>\n</quote>.</para>

      <para><emphasis>Any</emphasis> character can be quoted by a backslash; the
terms <quote>\=</quote> or <quote>\@</quote>, for instance, are valid quoted
pairs. But these quoted pairs don't have any special meaning to the library and
will be expanded to the quoted character itself. There is a number of quoted
pairs, though, that does have a special meaning and expands to some other value.
The complete list is shown below. Please note that the name <quote>quoted
pair</quote> is actually a bit inaccurate, because &varexp; supports some
expressions that are no <quote>pairs</quote> in the sense that they consist of
more than one quoted character. But the name <quote>quoted pair</quote> is very
common for them anyway, so I stuck with it.</para>

      <para>The quoted pairs supported by &varexp; are:</para>

      <variablelist>
        <varlistentry>
          <term><symbol>\t</symbol></term>
          <term><symbol>\r</symbol></term>
          <term><symbol>\n</symbol></term>
          <listitem>
            <para>These expressions are replaced by a <keysym>tab</keysym>, a
<keysym>carrige return</keysym> and a <keysym>newline</keysym>
respectively.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\<replaceable>abb</replaceable></term>
          <listitem>
            <para>This expression is replaced by the value of the octal number
<replaceable>abb</replaceable>. Valid digits for <replaceable>a</replaceable>
are in the range from 0 to 3; either position <replaceable>b</replaceable> may
be in the range from 0 to 7. Please note that an octal expression is recognized
only if the backslash is followed by <emphasis>three</emphasis> valid digits!
The expression <quote>\1a7</quote>, for example, is interpreted as the
quoted pair <quote>\1</quote> followed by the verbatim text
<quote>a7</quote>, because <quote>a</quote> is not valid for octal
numbers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x<replaceable>aa</replaceable></symbol></term>
          <listitem>
            <para>This expression is replaced by the value of the hexadecimal
number $<replaceable>aa</replaceable>. Both positions
<replaceable>a</replaceable> must be in the range from 0 to 9 or from
<quote>a</quote> to <quote>f</quote>. For the letters, either case is
recognized, so <quote>\xBB</quote> and <quote>\xbb</quote> will yield the same
result.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x{&hellip;}</symbol></term>
          <listitem>
            <para>This expression denotes a set of grouped hexadecimal numbers.
The <replaceable>&hellip;</replaceable> part may consist of an arbitrary number
of hexadecimal pairs, such as in <quote>\x{}</quote>, <quote>\x{ff}</quote>, or
<quote>\x{55ffab04}</quote>. The empty expression <quote>\x{}</quote> is a
no-op; it will not produce any output.</para>

            <para>This construct may be useful to specify multi-byte characters
(as in Unicode). <quote>\x{0102}</quote> is effectively equivalent to
<quote>\x01\x02</quote>, but the grouping of values may be useful in other
contexts, even though for &varexp; it makes no difference.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Arrays of Variables</title>

      <para>In addition to normal variables, &varexp; also supports arrays of
variables. An array may only be accessed in a complex expression --
<quote>$NAME[1]</quote> is not correct syntax. Use <quote>${NAME[1]}</quote>
instead. The reason for this limitation is that the brackets used to specify the
index (<quote>[</quote> and <quote>]</quote>) have a different meaning in
ordinary text; see <xref linkend="looping"> for further discussion.</para>

      <para>Which variable is an index and which is not is entirely up to the
application developer. In some applications, every array may be accessed as an
array, too. In other applications, normal variables and arrays are different
things. &varexp; does not dictate this. There exists the convention that
accessing an array with a negative index, such as <quote>${ARRAY[-1]}</quote>
should return the number of elements the array contains. But again, this is not
a behavior required by &varexp;; different applications may behave differently
here.</para>

      <para>When specifying the index of the array's element you wish to access,
you can use complete arithmetic expressions to calculate the entry. &varexp;
supports the operands <quote>+</quote> (addition), <quote>-</quote>
(subtractin), <quote>*</quote> (multiplication), <quote>/</quote> (division),
and <quote>+</quote> (modulo).</para>

      <para>These operations may be used on any signed integer. A valid
expression is, for example: <quote>${ARRAY[-12/4+5]}</quote>. Please note that
&varexp; follows the usual operator precedence. To group expressions
explicitely, put brackets around them:
<quote>${ARRAY[-12/(2+4)]}</quote>.</para>

      <para>In any place you can write a number in such an expression, you can
also use a simple or complex variable expression. If <quote>$TWO</quote> is
<quote>2</quote>, the following expression would access the 5th entry in the
<quote>$FOO</quote> array: <quote>${FOO[10/$TWO}</quote>.</para>
    </sect2>

    <sect2 id="looping">
      <title>Looping</title>

      <para>Obviously, arithmetic in array indices would be quite pointless
without a looping construct. &varexp; offers such a costruct, which can model
both a <quote>for</quote> and a <quote>while</quote> loop. Let's start with the
second version, which is slightly simpler.</para>

      <para>If the index delimiters <quote>[</quote> and <quote>[</quote> are
found in the text, the start a looping construct. An example would be
<quote>This is a test: [ $FOO ]</quote>. What happens now is that all text
between the loop-delimiters is repeated again and again until all variables
found in the body of the loop say they're undefined for the current index. The
current index starts counting at zero (0) and is increased with every interation
of the loop. In the index-specifier of the variable, it is available as
<quote>#</quote>.</para>

      <para>Hence, if we assume that the variable <quote>ARRAY[]</quote> had
three entries: <quote>entry1</quote>, <quote>entry2</quote>, and
<quote>entry3</quote>, then the loop <quote>[${ARRAY[i]}]</quote> would expand
to <quote>entry1entry2entry3</quote>. Once the conter reached index 4,
<quote>all</quote> arrays in the loop's body are undefined.</para>

      <para>That raises the question what the first example we presented,
<quote>This is a test: [ $FOO ]</quote>, would expand to? The answer is: To the
empty string! The loop would start expanding the body with index 0 and right at
the very first iteration, all arrays in the body were empty -- that is, no array
would have been expanded, because there weren't any arrays.</para>

      <para>Thus, this form of looping only makes sense if you
<emphasis>do</emphasis> specify arrays in the loop's body. If you do, though,
you can do some weird things, like <quote>[${ARRAY[#%2]}]</quote>, what expands
to <quote>${ARRAY[0]}</quote> for even numbers and to <quote>${ARRAY[1]}</quote>
for odd numbers. But the expression has another property: It will never
terminate, because the array-loopup will never fail, assuming that indices 0 and
1 are defined!</para>

      <para>That is unfortunate but can't be helped, I'm afraid. Users of
&varexp; may choose to disable looping for the users of their application to
prevent the end-user from shooting himself in the foot with infinite loops,
though. But if you want to use loops, you must know what you're doing. There
ain't no such thing as a free lunch, right?</para>

      <para>There is another form of the looping construct available, that
resembles a <quote>for</quote> loop more closely. In this form, the start value,
the step value and the stop value of the loop can be specified explicitely like
this:
<quote>[$FOO]{<replaceable>start</replaceable>,<replaceable>step</replaceable>,<replaceable>stop</replaceable>}</quote>.
This loop will start to expand the body using index
<replaceable>start</replaceable>, it will increase the current index in each
iteration by <replaceable>step</replaceable>, and it will terminate when the
current index is greater than <replaceable>stop</replaceable>. (Please note that
<quote>greater than</quote> is concept that needs much thought if you use
negative values here! There may be some infinite loops coming. You have been
warned.)</para>

      <para>If any of the first two values are omitted, the following defaults
will be assumed: <replaceable>start</replaceable> = 0 and
<replaceable>step</replaceable> = 1. If <replaceable>stop</replaceable> is
omitted, the loop will terminate if none of the arrays in the loop's body is
defined for the current index. Consequently, using the loop-limits
<quote>{,,}</quote> is equivalent to not specifying any limits at all.</para>

      <para>Since most users will not need the <replaceable>step</replaceable>
parameter frequently, a shorter form
<quote>{<replaceable>start</replaceable>,<replaceable>stop</replaceable>}</quote>
is allowed, too.</para>

      <para>By the way: Loops may be nested. :-)</para>

      <para>To confuse the valued reader completely, let's look at this final
example. Assume that the arrays <quote>${FOO[]}</quote> and
<quote>${BAR[]}</quote> have the following values:</para>

      <informalexample>
        <literallayout>    FOO[0] = "foo0"
    FOO[1] = "foo1"
    FOO[2] = "foo2"
    FOO[3] = "foo3"

and

    BAR[0] = "bar0"
    BAR[1] = "bar1"</literallayout>
      </informalexample>

      <para>Then the expression:</para>

      <informalexample>
        <literallayout>    [${BAR[#]}: [${FOO[#]}${FOO[#+1]:+, }]${BAR[#+1]:+; }]</literallayout>
      </informalexample>

      <para>would expand to:</para>

      <informalexample>
        <literallayout>    bar0: foo0, foo1, foo2, foo3; bar1: foo0, foo1, foo2, foo3</literallayout>
      </informalexample>

      <para>Have fun!</para>
    </sect2>

    <sect2>
      <title>The Complete EBNF Grammar</title>

    <informalexample>
      <screen>
input      : ( TEXT
              | variable
              | START-INDEX input END-INDEX ( loop-limits )?
              )*

loop-limits: START-DELIM
                (numexp)? ',' (numexp)? ( ',' (numexp)? )?
             END-DELIM


variable   : '$' (name|expression)

expression : START-DELIM (name|variable)+
             (START-INDEX num-exp END-INDEX)?
             (':' command)* END-DELIM

name       : (VARNAME)+

command    : '-' (EXPTEXT|variable)+
           | '+' (EXPTEXT|variable)+
           | 'o' (NUMBER ('-'|',') (NUMBER)?)
           | '#'
           | '*' (EXPTEXT|variable)+
           | 's' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/'
             ('g'|'i'|'t')*
           | 'y' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/'
           | 'p' '/' NUMBER '/' (variable|SUBSTTEXT)* '/' ('r'|'l'|'c')
           | 'l'
           | 'u'

num-exp    : operand
           | operand ('+'|'-'|'*'|'/'|'%') num-exp

operand    : ('+'|'-')? NUMBER
           | CURR-INDEX
           | '(' num-exp ')'
           | variable

START-DELIM: '{'

END-DELIM  : '}'

START-INDEX: '['

END-INDEX  : ']'

CURR-INDEX : '#'

VARNAME    : '[a-zA-Z0-9_]+'

NUMBER     : '[0-9]+'

SUBSTTEXT  : '[^$/]'

EXPTEXT    : '[^$}:]+'

TEXT       : '[^$[\\]]+'
</screen>
      </informalexample>
    </sect2>

  </sect1>

  <sect1>
    <title>The &expand; Function</title>
    <para></para>
  </sect1>

  <sect1>
    <title>The &unescape; Function</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Exceptions Thrown by &varexp;</title>

    <variablelist>
      <varlistentry>
        <term><exceptionname>incomplete_hex</exceptionname></term>
        <listitem>
          <para>The input buffer ended before a hexadecimal
<quote>\x<replaceable>aa</replaceable></quote> quoted pair was complete.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_hex</exceptionname></term>
        <listitem>
          <para>Any of the <replaceable>a</replaceable> characters in an
<quote>\x<replaceable>aa</replaceable></quote> quoted pair was not a valid
hexadecimal character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>octal_too_large</exceptionname></term>
        <listitem>
          <para>The first digit of an octal
<quote>\<replaceable>abb</replaceable></quote> quoted pair was not in the range
from 0 to 3.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_octal</exceptionname></term>
        <listitem>
          <para>A digit of an octal
<quote>\<replaceable>abb</replaceable></quote> expression was not in the range
from 0 to 7.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incomplete_octal</exceptionname></term>
        <listitem>
          <para>The input buffer ended in the before an octal
<quote>\<replaceable>abb</replaceable></quote> quoted pair was complete.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incomplete_grouped_hex</exceptionname></term>
        <listitem>
          <para>A hexadecimal
<quote>\x{<replaceable>&hellip;</replaceable>}</quote> expression contained an
odd number of characters in the <replaceable>&hellip;</replaceable>
parameter.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incorrect_class_spec</exceptionname></term>
        <listitem>
          <para>In a character range specification
<quote><replaceable>a</replaceable>-<replaceable>b</replaceable></quote>, the
start of the range <replaceable>a</replaceable> was <quote>bigger</quote> (in
terms of the ASCII code) than the end of the range
<replaceable>b</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_configuration</exceptionname></term>
        <listitem>
          <para>&expand;'s configuration is inconsistent.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incomplete_variable_spec</exceptionname></term>
        <listitem>
          <para>Either, the input buffer ended right after a variable
initializer token (<quote>$</quote>) was found, or a complex variable expression
was not correctly terminated, meaning, that the closing <quote>}</quote> bracket
was missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>undefined_variable</exceptionname></term>
        <listitem>
          <para>This exception is supposed to be thrown by the user-provided
callback when an unknown variable is requested.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>input_isnt_text_nor_variable</exceptionname></term>
        <listitem>
          <para>This exception is throw in the rather unlikely case that the
parser could not process the complete buffer, yet no error occured. When this
should happen? Well, not at all. But since the error is theoretically possible,
I defined it.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>unknown_command_char</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:<replaceable>c</replaceable>}</quote>
expression, <replaceable>c</replaceable> was none of the supported
operations.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>malformatted_replace</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:s&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>unknown_replace_flag</exceptionname></term>
        <listitem>
          <para>An unsupported flag was provided in an
<quote>${NAME:s&hellip;}</quote> expression.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_regex_in_replace</exceptionname></term>
        <listitem>
          <para>The regular expression given as pattern in an
<quote>${NAME:s&hellip;}</quote> expression failed to compile.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>missing_parameter_in_command</exceptionname></term>
        <listitem>
          <para>The required <replaceable>word</replaceable> parameter was
missing in an <quote>${NAME:-<replaceable>word</replaceable>}</quote>,
<quote>${NAME:+<replaceable>word</replaceable>}</quote>, or
<quote>${NAME:*<replaceable>word</replaceable>}</quote> expression.
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>empty_search_string</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:s&hellip;} expression, the
<replaceable>search</replaceable> parameter was empty.</quote>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>missing_start_offset</exceptionname></term>
        <listitem>
          <para>The <replaceable>start</replaceable> parameter was missing in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
expression.</para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><exceptionname>invalid_offset_delimiter</exceptionname></term>
        <listitem>
          <para>In an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression, the delimiter between <replaceable>start</replaceable> and
<replaceable>end</replaceable> was neither a <quote>,</quote> nor a
<quote>-</quote>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>range_out_of_bounds</exceptionname></term>
        <listitem>
          <para>The <replaceable>stop</replaceable> parameter in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression exceeded the actual length of the string.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>offset_out_of_bounds</exceptionname></term>
        <listitem>
          <para>The <replaceable>start</replaceable> parameter in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression exceeded the actual length of the string.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>offset_logic</exceptionname></term>
        <listitem>
          <para>In an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
expression, <replaceable>start</replaceable> was larger than
<replaceable>stop</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>malformatted_transpose</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:y&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>transpose_classes_mismatch</exceptionname></term>
        <listitem>
          <para>The <replaceable>ochars</replaceable> range has not the same
number of characters as the <replaceable>nchars</replaceable> range in an
<quote>${NAME:y&hellip;}</quote> expression.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>empty_transpose_class</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:y&hellip;}</quote> expression, either the
<replaceable>ochars</replaceable> or the <replaceable>nchars</replaceable> range
was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incorrect_transpose_class_spec</exceptionname></term>
        <listitem>
          <para>In a character range given in an
<quote>${NAME:y&hellip;}</quote> expression, the start of the range was larger
(in terms of the ASCII code) than the end character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>malformatted_padding</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:p&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>missing_padding_width</exceptionname></term>
        <listitem>
          <para>The <replaceable>width</replaceable> parameter in an
<quote>${NAME:p&hellip;}</quote> expression was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>empty_padding_fill_string</exceptionname></term>
        <listitem>
          <para>The <replaceable>fill</replaceable> parameter in an
<quote>${NAME:p&hellip;}</quote> expression was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>unknown_quoted_pair_in_replace</exceptionname></term>
        <listitem>
          <para>In the <replaceable>replace</replaceable> parameter of an
<quote>${NAME:s&hellip;}</quote> expression, an invalid quoted pair was
specified. Valid are only quoted pairs of the form
<quote>\<replaceable>digit</replaceable></quote>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>submatch_out_of_range</exceptionname></term>
        <listitem>
          <para>In the <replaceable>replace</replaceable> parameter an
<quote>${NAME:s&hellip;}</quote> expression, a submatch with a number greater
than the number of submatches defined in the <replaceable>search</replaceable>
parameter was accessed.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incomplete_quoted_pair</exceptionname></term>
        <listitem>
          <para>The input buffer ended right after a backslash character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>array_lookups_are_unsupported</exceptionname></term>
        <listitem>
          <para>This exception is supposed to be thrown by the user-supplied
callback when the array lookup function is called even though arrays should not
occur. If you don't intend to support arrays, though, you should disable them
via the parser's configuration instead.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_char_in_index_spec</exceptionname></term>
        <listitem>
          <para>The index specification of array variable contains an invalid
character, a character that is not part of a <literal>num-exp</literal> that
is.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>incomplete_index_spec</exceptionname></term>
        <listitem>
          <para>The input buffer ended in an open variable index specification;
meaning that the terminating <quote>]</quote> delimiter was missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>unclosed_bracket_in_index</exceptionname></term>
        <listitem>
          <para>An arithmetic group in an index specification was closed
properly with a <quote>)</quote> bracket.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>division_by_zero_in_index</exceptionname></term>
        <listitem>
          <para>Division by zero error in index specification.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>unterminated_loop_construct</exceptionname></term>
        <listitem>
          <para>The buffer ended in the midst of on open looping
construct.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>invalid_char_in_loop_limits</exceptionname></term>
        <listitem>
          <para>The looping limits specification of contained invalid
characters.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1>
    <title>Example Program</title>

    <para>The following source code may be found in
<filename>regression-test/expand5.cc</filename>. You might want to check the
other test programs there for more complex examples. Especially
<filename>expand6.cc</filename>, which also makes use of arrays and
loops!</para>

    <programlisting>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cerrno&gt;
#include &lt;cstring&gt;
#include "../varexp.hh"
using namespace varexp;
using namespace std;

struct env_lookup : public callback_t
    {
    virtual void operator()(const string&amp; name, string&amp; data)
        {
        const char* p = getenv(name.c_str());
        if (p == NULL)
            throw undefined_variable();
        else
            data = p;
        }
    virtual void operator()(const string&amp; name, int idx, string&amp; data)
        {
        throw runtime_error("Not implemented.");
        }
    };

int main(int argc, char** argv)
    {
    const char* input =                            \
        "\\$HOME      = '${HOME}'\\n"              \
        "\\$OSTYPE    = '${$FOO${BAR}}'\\n"        \
        "\\$TERM      = '${TERM}'\\n";
    const char* output =                           \
        "$HOME      = '/home/regression-tests'\n"  \
        "$OSTYPE    = 'regression-os'\n"           \
        "$TERM      = 'regression-term'\n";
    string tmp;
    env_lookup lookup;

    if (setenv("HOME", "/home/regression-tests", 1) != 0 ||
        setenv("OSTYPE", "regression-os", 1) != 0 ||
        setenv("TERM", "regression-term", 1) != 0 ||
        setenv("FOO", "OS", 1) != 0 ||
        setenv("BAR", "TYPE", 1) != 0)
        {
        printf("Failed to set the environment: %s.\n",
               strerror(errno));
        return 1;
        }
    unsetenv("UNDEFINED");

    expand(input, tmp, lookup);
    unescape(tmp, tmp, true);

    if (tmp != output)
        {
        printf("The buffer returned by var_expand() " \
               "is not what we expected.\n");
        return 1;
        }

    return 0;
    }</programlisting>

  </sect1>

  <sect1>
    <title>License</title>

    <para>This library is based on the OSSP var library, which I developed for
Cable &amp; Wireless Deutschland. I hereby grant permission to use all files
included in this distribution under the same terms as the original
version:</para>

    <literallayout>    Copyright (c) 2002 Peter Simons &lt;simons@computer.org&gt;
    Copyright (c) 2001 The OSSP Project (http://www.ossp.org/)
    Copyright (c) 2001 Cable & Wireless Deutschland (http://www.cw.com/de/)

    Permission to use, copy, modify, and distribute this software for
    any purpose with or without fee is hereby granted, provided that
    the above copyright notice and this permission notice appear in all
    copies.

    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHORS AND COPYRIGHT HOLDERS AND THEIR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.</literallayout>
  </sect1>

</article>

<!--
Local Variables:
mode: sgml
fill-column:80
End:
-->

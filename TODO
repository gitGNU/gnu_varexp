                              libvarexp

 - Eine Variable kann im Text in der Form $name oder ${name} angegeben
   werden, wobei die Wahl der Klammern '{' '}' und des '$'
   parametriesiert werden können.

 - Gültige Zeichen für einem Variablennamen sind: [a-z0-9_] und '['
   sowie ']' selber.

 - Ein echtes '$'-Zeichen im Text kann durch Voranstellung eines
   wählbaren Escapezeichen dargestellt werden. Default ist der
   Backslash ('\').

 - Der tatsächliche Lookup des Inhaltes der Variable geschieht über
   eine Callback-Funktion:

    enum
	{
	VAR_OK,
	VAR_NOTFOUND,
	VAR_ERR_XXX,
	VAR_ERR_XXX,
	   :
	}
    var_rc_t;

    var_rc_t (*var_lookup_cb)(void *ctx,
			      const char *varbegin,
			      const char* varend,
			      char *bufptr, size_t bufmax, size_t *buflen
			      );

 - Der Aufrufer der Funktion soll steuern können, wie sich die Library
   verhält, wenn eine Variable nicht existiert. Denkbar sind:

    - Abbruch mit Fehler,
    - die Variable wird zu "", oder
    - der Ausdruck wird unverändert in den Ausgabetext übernommen,
      sodaß eventuell ein zweiter Pass gemacht werden kann.

 - ${parameter:-word} wird normal expandiert. Wenn "parameter" leer
   ist, wird stattdessen "word" eingesetzt.

 - ${parameter:?word} wird normal expandiert. Wenn "parameter" leer
   ist, bricht die Verarbeitung mit Fehler ab und "word" wird als
   Begründung zurückgegeben.

 - ${parameter:+word} substituiert die Expansion von "${word}" wenn
   "parameter" nicht leer ist, sonst wird "" substituiert.

 - ${parameter:o<offset>} und ${parameter:o<offset>-<length>}
   substituiert den Inhalt von "parameter" ab Zeichen "offset" bis zum
   Ende oder -- in der zweiten Form -- die nächsten "length" Zeichen.

 - ${parameter:#} expandiert zur Länge des Inhaltes von "parameter".

 - ${parameter:s/pattern/string/[gti]} expandiert "parameter" und
   führt dann eine Ersetzung mittels des regulären Ausdrucks "pattern"
   durch. Wird das 'g'-Flag angegeben, wird nicht nur eine Instanz von
   "pattern" durch "string" ersetzt, sondern alle. Das 't'-Flag
   signalisiert, daß eine reine Text-Ersetzung ohne Unterstützung von
   regulären Ausdrücken gewünscht ist. Das 'i'-Flag besagt, daß die
   Suche nach "pattern" case-insensitiv durchgeführt wird.

 - ${parameter:Q} escaped vor der Expansion alle Shell-Meta-Zeichen.

 - ${parameter:L} wandelt den Inhalt von "parameter" in
   Kleinbuchstaben, bevor es die Variable expandiert.

 - ${parameter:U} wandelt den Inhalt von "parameter" in
   Großbuchstaben, bevor es die Variable expandiert.

 - ${parameter:*word} expandiert zum leeren Wort, wenn "parameter"
   nicht leer ist.

 - ${parameter:y/ochars/nchars/} expandiert den Inhalt von "parameter"
   und transformiert dabei nach dem Prinzip von tr(1) die "ochars" im
   Text zu "nchars".

 - Jedes Vorkommen eines der folgenden Konstrukte im Text wird durch
   das zugehörige Sonderzeichen ersetzt.

       \t          tab                   (HT, TAB)
       \n          newline               (LF, NL)
       \r          return                (CR)
       \f          form feed             (FF)
       \a          alarm (bell)          (BEL)
       \e          escape (think troff)  (ESC)
       \033        octal char
       \x1B        hex char
       \x{263a}    wide hex char         (Unicode SMILEY)

 - Interne Strukturen:

    struct configuration
	{
	char varinit = '$';
	char openbracket = '{';
	char closebracket = '}';
	char escape = '\\';
	char force_expand = TRUE;
	};

    struct state
	{
	char* begin;
	char* end;
	char do_we_own_buffer;
	};

 - Beispiele:

     $name
     $name[test]
     ${name}
     ${name[test]}
     $[name\[test\]]
     $$name
     $${name}
     ${name:s/foo/bar/g}
     ${foobar:s/${name:s/foo/bar/g}/test} ??????

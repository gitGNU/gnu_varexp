<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY version SYSTEM "../VERSION">
<!ENTITY varexp "<application>libvarexp</application>">
<!ENTITY unescape "<function>varexp::unescape</function>">
<!ENTITY expand "<function>varexp::expand</function>">
]>

<article lang="en">
  <articleinfo>
    <title>Variable Expression Library &version;</title>
    <author>
      <firstname>Peter</firstname>
      <surname>Simons</surname>
      <affiliation>
        <address><email>simons@computer.org</email></address>
      </affiliation>
    </author>
  </articleinfo>

  <sect1>
    <title>Purpose of this Library</title>

    <para>&varexp; is a C++ library that allows its users to detach any kind of
information from the representation of that information by providing a
simple-to-use but powerful text-template mechanism. Similar mechanisms have been
available in tools like
<citerefentry><refentrytitle>sh</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
<citerefentry><refentrytitle>make</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
or
<citerefentry><refentrytitle>perl</refentrytitle><manvolnum>1</manvolnum></citerefentry>
forever and have proven to be very useful. The basic idea is that the relevant
information is made available in variables, which the author of the template can
than use within the text itself as he or she sees fit.</para>

    <para>Consider, for example, a tool that will calculate the monthly
financial reports of a small company. Such a program should only
<emphasis>calculate</emphasis> the required values, it should not worry about
writing the resulting reports into an HTML file, a CSV file, or whatever format
is desired. Instead, it should make the results of the calculation available in
the variables <quote>$TURNOVER</quote>, <quote>$PROFIT</quote>, and
<quote>$INCREASE</quote>. Then, using &varexp;, it could load an arbitrary
template file and have the actual values inserted at the apropriate positions.
Without changing a single line of code, one could generate the monthly report in
HTML:</para>

    <informalexample>
      <screen>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Financial Report&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;h1&gt;Financial report&lt;/h1&gt;

    &lt;p&gt;This month, our glorious company reached a
total turnover of ${TOTAL} Euros, totalling ${PROFIT}
Euros before taxes. That means we have increased our
profit by ${INCREASE} percent compared to last
month.&lt;/p&gt;

  &lt;/body&gt;
&lt;/html&gt;</screen>
    </informalexample>

    <para>Or you can send it out as a plain-text e-mail:</para>

    <informalexample>
      <screen>From: nobody@example.org (Monthly Financial Data)
Subject: This month's financial report

Dear Colleagues,

we have earned a total of ${PROFIT} Euros this month!
This means that we have increased profits by ${PROFIT}
percent compared to last month, totalling a turnover
of ${TURNOVER} of Euros.

Sincerely yours,
    The Statistics Program</screen>
    </informalexample>

    <para>Even better, by using such templates to generate the output you are
effectively independent of the language you choose! The last report, for
example, could also read:</para>

    <informalexample>
      <screen>From: nobody@example.org (Grssss&ouml;tmpf!)
Subject: Ajahaha Mzoodeutschmark

Nuwarskvu,

Quhu&szlig;aour Maou Ahosetuh Cravullitstziki Nakaou ${PROFIT}
Akqiss&auml;e&uuml;&szlig; Blaga: ${TURNOVER} Stauhr ${INCREASE}!!!!</screen>
    </informalexample>

    <para>This version is -- as you can probably easily recognize -- in
German.</para>

    <para>&varexp; offers application developers two functions, that will do all
this for them, plus, the end-user has <emphasis>numerous</emphasis> ways not
only to insert variables into his template files but to modify the variables
contents on the fly, do full-blown regular expression search-and-replaces, or
loop over the contents of arrays of variables.</para>

    <para>Furthermore, the parser included in &varexp; can be re-configured to
use tokens different from the ones shown in the examples; one could as well use
<quote>%{NAME}</quote>, change the set of allowed characters for variable names,
etc.</para>

    <para>And last but certainly not least, these variables are not limited to
<quote>environment variables</quote> at all. The programmer is free to provide a
callback function to &varexp; that will be used to map a variable name to its
contents. Thus, the variables your application provides, can reside internally
completely. In fact, they can reside pretty much anywhere you want and they
contain pretty much anything you want, as long as <emphasis>you</emphasis> write
the callback.</para>

  </sect1>

  <sect1>
    <title>Expressions Supported by the Library</title>

    <sect2>
      <title>Variable Expressions</title>

      <para>&varexp; distinguishes variables into simple and complex
expressions. A simple expression has the form <quote>$NAME</quote> and will
basically only replace the variable in the text buffer with its contents.
Complex expressions have the form
<quote>${NAME:operation1:operation2:&hellip;}</quote> and may perform various
operations on the variable's contents before inserting it into the text
buffer.</para>

      <para>Please note that due to the way simple expressions are parsed, it
may not always be possible to use the simple-expression form even though you do
not want to perform any operations. If your input text was <quote>This is a
$FOObar</quote>, but the last <quote>bar</quote> part is meant to be a literal
string, you'd have use <quote>This is a ${FOO}bar</quote>, because the parser
will interpret any valid variable-name character following the dollar as part of
the variable name; it will not recognize that <quote>$FOO</quote> would exist
while <quote>$FOObar</quote> would not.</para>

      <para>Also, &varexp; does not distinguish case in any way. For the
library, <quote>$FoObAr</quote> and <quote>$fOoBaR</quote> are just strings --
whether they refer to the same variable or not is entirely up to the application
that provides the callback used to resolve variables to their contents.</para>

      <para>If you want to enter a text like <quote>$foo</quote> literally,
you'll have to escape the <quote>$</quote> sign by prefacing it with a
backslash: <quote>\$foo</quote>. Then &varexp; won't interpret this expression
as a variable.</para>
    </sect2>

    <sect2>
      <title>Operations on Variables</title>

      <para>In addition to just inserting the variable's contents into the
buffer, you can use various operations to modify its contents before the
expression is expanded. Such operations are used by appending a colon plus the
apropriate command character to the variable name in complex expression, for
example: <quote>${FOOBAR:l}</quote>. Furthermore, you can chain any number of
operations simply by appending another command to the last one:
<quote>${FOOBAR:l:u:l:u:&hellip;}</quote>.</para>

      <para>The supported operations are:</para>

      <variablelist>
        <varlistentry>
          <term><literal>${NAME:#}</literal></term>
          <listitem>
            <para>This operation will expand the expression to the length of the
contents of <literal>$NAME</literal>. If, for example, <literal>$FOO</literal>
is <quote>foobar</quote>, then <literal>${FOO:#}</literal> will result in
<quote>6</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:l}</literal></term>
          <listitem>
            <para>This operation will turn the contents of
<literal>$NAME</literal> to all lower-case, using the system routine
<citerefentry><refentrytitle>tolower</refentrytitle><manvolnum>3</manvolnum></citerefentry>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:u}</literal></term>
          <listitem>
            <para>This operation will turn the contents of
<literal>$NAME</literal> to all upper-case, using the system routine
<citerefentry><refentrytitle>toupper</refentrytitle><manvolnum>3</manvolnum></citerefentry>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:*<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is empty. If <literal>$NAME</literal> is not empty,
it will expand to an empty string.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:*${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:-<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is empty. If <literal>$NAME</literal> is not empty,
it will evaluate to the <literal>$NAME</literal>'s contents.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:-${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:+<replaceable>word</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to <replaceable>word</replaceable>
if <literal>$NAME</literal> is not empty. If <literal>$NAME</literal> is empty,
it will expand to an empty string.</para>

            <para><replaceable>word</replaceable> can be an arbitrary text. In
particular, it may contain other variables or even complex variable expressions,
for example: <quote>${FOO:+${BAR:u}}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to a part of
<literal>$NAME</literal>'s contents, which starts at
<replaceable>start</replaceable> and ends at <replaceable>end</replaceable>.
Both parameters <replaceable>start</replaceable> and
<replaceable>end</replaceable> are unsigned numbers.</para>

            <para>Please note that the character at position
<replaceable>end</replaceable> is <emphasis>included</emphasis> in the result;
<quote>${FOOBAR:o3,4}</quote>, for instance, will return a two-character string.
Also, please note that start positions begin at zero (0)!</para>

            <para>If the <replaceable>end</replaceable> parameter is not
specified, as in <quote>${FOOBAR:o3,}</quote>, the operation will return the
string starting from position 3 to the end of the string.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:o<replaceable>start</replaceable>-<replaceable>length</replaceable>}</literal></term>
          <listitem>
            <para>This operation will expand to a part of
<literal>$NAME</literal>'s contents, which starts at
<replaceable>start</replaceable> and ends at
<quote><replaceable>start</replaceable>+<replaceable>length</replaceable></quote>.
Both parameters <replaceable>start</replaceable> and
<replaceable>end</replaceable> are unsigned numbers.</para>

            <para><quote>${FOOBAR:o3-4}</quote>, for example, means to return
the next 4 charaters starting at position 3 in the string. Please note that
start positions begin at zero (0)!</para>

            <para>If the <replaceable>end</replaceable> parameter is left out,
as in <quote>${FOOBAR:o3-}</quote>, the operation will return the string from
position 3 to the end.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:s/<replaceable>pattern</replaceable>/<replaceable>string</replaceable>/<replaceable>gti</replaceable>}</literal></term>
          <listitem>
            <para>This operation will perform a search-and-replace operation on
the contents of <literal>$NAME</literal> and return the result. The behavior of
the search-and-replace may be modified by the following flags: If a
<literal>t</literal> flag has been provided, a plain text search-and-replace is
performed, otherwise, the default is to do a regular expression
search-and-replace as in the system utility
<citerefentry><refentrytitle>sed</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
If the <literal>g</literal> flag has been provided, the search-and-replace will
replace <emphasis>all</emphasis> instances of <replaceable>pattern</replaceable>
by <replaceable>replace</replaceable>, instead of replacing only the first
instance (the default). If the <literal>i</literal> flag has been provided, the
search-and-replace will take place case-insensitively, otherwise, the default is
to search case-sensitively.</para>

            <para>The parameters <replaceable>pattern</replaceable> and
<replaceable>replace</replaceable> can be an arbitrary text. In particular, they
may contain other variables or even complex variable expressions, for example:
<quote>${FOO:s/${BAR:u}/$FOO/ti}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:y/<replaceable>ochars</replaceable>/<replaceable>nchars</replaceable>/}</literal></term>
          <listitem>
            <para>This operation will translate all characters in the contents
of <literal>$NAME</literal> that are found in the
<replaceable>ochars</replaceable> class to the corresponding character in the
<replaceable>nchars</replaceable> class -- just like the system utility
<citerefentry><refentrytitle>tr</refentrytitle><manvolnum>1</manvolnum></citerefentry>
does. Both <replaceable>ochars</replaceable> and
<replaceable>nchars</replaceable> may contain character range specifications,
for example <quote>a-z0-9</quote>. A hyphon as the first or last character of
the class specification is interpreted literally. Both the
<replaceable>ochars</replaceable> and the <replaceable>nchars</replaceable>
class must contain the same number of characters after all ranges are expanded,
or an error is returned.

          <para>If, for example, <quote>$FOO</quote> contains
<quote>foobar</quote>, then <quote>${FOO:y/a-z/A-Z/}</quote> would yield
<quote>FOOBAR</quote>. Another goodie is to use that operation to ROT13-encrypt
or decrypt a string with the expression
<quote>${FOO:y/a-z/n-za-m/}</quote>.</para>

            <para>The parameters <replaceable>ochars</replaceable> and
<replaceable>nchars</replaceable> can be an arbitrary text. In particular, they
may contain other variables or even complex variable expressions, for example:
<quote>${FOO:y/${BAR:u}/$TEST/}</quote>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>${NAME:p/<replaceable>width</replaceable>/<replaceable>string</replaceable>/<replaceable>align</replaceable>}</literal></term>
          <listitem>
            <para>This operation will pad the contents of
<literal>$NAME</literal> with <replaceable>string</replaceable> according to the
<replaceable>align</replaceable> parameter, so that the result is at least
<replaceable>width</replaceable> characters long. Valid parameters for align are
<literal>l</literal> (left), <literal>r</literal> (right), or
<literal>c</literal> (center). The <replaceable>string</replaceable> parameter
may contain multiple characters, if you see any use for that.</para>

            <para>If, for example, <quote>$FOO</quote> is <quote>foobar</quote>,
then <quote>${FOO:p/20/./c}</quote> would yield
<quote>.......foobar.......</quote>; <quote>${FOO:p/20/./l}</quote> would yield
<quote>foobar..............</quote>; and <quote>${FOO:p/20/./r}</quote> would
yield <quote>..............foobar</quote>;</para>

            <para>The parameter <replaceable>string</replaceable> can be an
arbitrary text. In particular, it may contain other variables or even complex
variable expressions, for example: <quote>${FOO:p/20/${BAR}/r/}</quote>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="quoted-pairs">
      <title>Quoted Pairs</title>

      <para>In addition to the variable expressions discussed in the previous
sections, &varexp; can also be used to expand so called <quote>quoted
pairs</quote> in the text. Quoted pairs are well-known from programming
languages like C, for example. A quoted pair consists of the backslash followed
by another character, for example: <quote>\n</quote>.</para>

      <para><emphasis>Any</emphasis> character can be quoted by a backslash; the
terms <quote>\=</quote> or <quote>\@</quote>, for instance, are valid quoted
pairs. But these quoted pairs don't have any special meaning to the library and
will be expanded to the quoted character itself. There is a number of quoted
pairs, though, that does have a special meaning and expands to some other value.
The complete list is shown below. Please note that the name <quote>quoted
pair</quote> is actually a bit inaccurate, because &varexp; supports some
expressions that are no <quote>pairs</quote> in the sense that they consist of
more than one quoted character. But the name <quote>quoted pair</quote> is very
common for them anyway, so I stuck with it.</para>

      <para>The quoted pairs supported by &varexp; are:</para>

      <variablelist>
        <varlistentry>
          <term><symbol>\t</symbol></term>
          <term><symbol>\r</symbol></term>
          <term><symbol>\n</symbol></term>
          <listitem>
            <para>These expressions are replaced by a <keysym>tab</keysym>, a
<keysym>carrige return</keysym> and a <keysym>newline</keysym>
respectively.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\<replaceable>abb</replaceable></term>
          <listitem>
            <para>This expression is replaced by the value of the octal number
<replaceable>abb</replaceable>. Valid digits for <replaceable>a</replaceable>
are in the range from 0 to 3; either position <replaceable>b</replaceable> may
be in the range from 0 to 7. Please note that an octal expression is recognized
only if the backslash is followed by <emphasis>three</emphasis> valid digits!
The expression <quote>\1a7</quote>, for example, is interpreted as the
quoted pair <quote>\1</quote> followed by the verbatim text
<quote>a7</quote>, because <quote>a</quote> is not valid for octal
numbers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x<replaceable>aa</replaceable></symbol></term>
          <listitem>
            <para>This expression is replaced by the value of the hexadecimal
number $<replaceable>aa</replaceable>. Both positions
<replaceable>a</replaceable> must be in the range from 0 to 9 or from
<quote>a</quote> to <quote>f</quote>. For the letters, either case is
recognized, so <quote>\xBB</quote> and <quote>\xbb</quote> will yield the same
result.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x{&hellip;}</symbol></term>
          <listitem>
            <para>This expression denotes a set of grouped hexadecimal numbers.
The <replaceable>&hellip;</replaceable> part may consist of an arbitrary number
of hexadecimal pairs, such as in <quote>\x{}</quote>, <quote>\x{ff}</quote>, or
<quote>\x{55ffab04}</quote>. The empty expression <quote>\x{}</quote> is a
no-op; it will not produce any output.</para>

            <para>This construct may be useful to specify multi-byte characters
(as in Unicode). <quote>\x{0102}</quote> is effectively equivalent to
<quote>\x01\x02</quote>, but the grouping of values may be useful in other
contexts, even though for &varexp; it makes no difference.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Arrays of Variables</title>

      <para>In addition to normal variables, &varexp; also supports arrays of
variables. An array may only be accessed in a complex expression --
<quote>$NAME[1]</quote> is not correct syntax. Use <quote>${NAME[1]}</quote>
instead. The reason for this limitation is that the brackets used to specify the
index (<quote>[</quote> and <quote>]</quote>) have a different meaning in
ordinary text; see <xref linkend="looping"> for further discussion.</para>

      <para>Which variable is an index and which is not is entirely up to the
application developer. In some applications, every array may be accessed as an
array, too. In other applications, normal variables and arrays are different
things. &varexp; does not dictate this. There exists the convention that
accessing an array with a negative index, such as <quote>${ARRAY[-1]}</quote>
should return the number of elements the array contains. But again, this is not
a behavior required by &varexp;; different applications may behave differently
here.</para>

      <para>When specifying the index of the array's element you wish to access,
you can use complete arithmetic expressions to calculate the entry. &varexp;
supports the operands <quote>+</quote> (addition), <quote>-</quote>
(subtractin), <quote>*</quote> (multiplication), <quote>/</quote> (division),
and <quote>+</quote> (modulo).</para>

      <para>These operations may be used on any signed integer. A valid
expression is, for example: <quote>${ARRAY[-12/4+5]}</quote>. Please note that
&varexp; follows the usual operator precedence. To group expressions
explicitely, put brackets around them:
<quote>${ARRAY[-12/(2+4)]}</quote>.</para>

      <para>In any place you can write a number in such an expression, you can
also use a simple or complex variable expression. If <quote>$TWO</quote> is
<quote>2</quote>, the following expression would access the 5th entry in the
<quote>$FOO</quote> array: <quote>${FOO[10/$TWO}</quote>.</para>
    </sect2>

    <sect2 id="looping">
      <title>Looping</title>

      <para>Obviously, arithmetic in array indices would be quite pointless
without a looping construct. &varexp; offers such a costruct, which can model
both a <quote>for</quote> and a <quote>while</quote> loop. Let's start with the
second version, which is slightly simpler.</para>

      <para>If the index delimiters <quote>[</quote> and <quote>[</quote> are
found in the text, the start a looping construct. An example would be
<quote>This is a test: [ $FOO ]</quote>. What happens now is that all text
between the loop-delimiters is repeated again and again until all variables
found in the body of the loop say they're undefined for the current index. The
current index starts counting at zero (0) and is increased with every interation
of the loop. In the index-specifier of the variable, it is available as
<quote>#</quote>.</para>

      <para>Hence, if we assume that the variable <quote>ARRAY[]</quote> had
three entries: <quote>entry1</quote>, <quote>entry2</quote>, and
<quote>entry3</quote>, then the loop <quote>[${ARRAY[i]}]</quote> would expand
to <quote>entry1entry2entry3</quote>. Once the conter reached index 4,
<quote>all</quote> arrays in the loop's body are undefined.</para>

      <para>That raises the question what the first example we presented,
<quote>This is a test: [ $FOO ]</quote>, would expand to? The answer is: To the
empty string! The loop would start expanding the body with index 0 and right at
the very first iteration, all arrays in the body were empty -- that is, no array
would have been expanded, because there weren't any arrays.</para>

      <para>Thus, this form of looping only makes sense if you
<emphasis>do</emphasis> specify arrays in the loop's body. If you do, though,
you can do some weird things, like <quote>[${ARRAY[#%2]}]</quote>, what expands
to <quote>${ARRAY[0]}</quote> for even numbers and to <quote>${ARRAY[1]}</quote>
for odd numbers. But the expression has another property: It will never
terminate, because the array-loopup will never fail, assuming that indices 0 and
1 are defined!</para>

      <para>That is unfortunate but can't be helped, I'm afraid. Users of
&varexp; may choose to disable looping for the users of their application to
prevent the end-user from shooting himself in the foot with infinite loops,
though. But if you want to use loops, you must know what you're doing. There
ain't no such thing as a free lunch, right?</para>

      <para>There is another form of the looping construct available, that
resembles a <quote>for</quote> loop more closely. In this form, the start value,
the step value and the stop value of the loop can be specified explicitely like
this:
<quote>[$FOO]{<replaceable>start</replaceable>,<replaceable>step</replaceable>,<replaceable>stop</replaceable>}</quote>.
This loop will start to expand the body using index
<replaceable>start</replaceable>, it will increase the current index in each
iteration by <replaceable>step</replaceable>, and it will terminate when the
current index is greater than <replaceable>stop</replaceable>. (Please note that
<quote>greater than</quote> is concept that needs much thought if you use
negative values here! There may be some infinite loops coming. You have been
warned.)</para>

      <para>If any of the first two values are omitted, the following defaults
will be assumed: <replaceable>start</replaceable> = 0 and
<replaceable>step</replaceable> = 1. If <replaceable>stop</replaceable> is
omitted, the loop will terminate if none of the arrays in the loop's body is
defined for the current index. Consequently, using the loop-limits
<quote>{,,}</quote> is equivalent to not specifying any limits at all.</para>

      <para>Since most users will not need the <replaceable>step</replaceable>
parameter frequently, a shorter form
<quote>{<replaceable>start</replaceable>,<replaceable>stop</replaceable>}</quote>
is allowed, too.</para>

      <para>By the way: Loops may be nested. :-)</para>

      <para>To confuse the valued reader completely, let's look at this final
example. Assume that the arrays <quote>${FOO[]}</quote> and
<quote>${BAR[]}</quote> have the following values:</para>

      <informalexample>
        <literallayout>    FOO[0] = "foo0"
    FOO[1] = "foo1"
    FOO[2] = "foo2"
    FOO[3] = "foo3"

and

    BAR[0] = "bar0"
    BAR[1] = "bar1"</literallayout>
      </informalexample>

      <para>Then the expression:</para>

      <informalexample>
        <literallayout>    [${BAR[#]}: [${FOO[#]}${FOO[#+1]:+, }]${BAR[#+1]:+; }]</literallayout>
      </informalexample>

      <para>would expand to:</para>

      <informalexample>
        <literallayout>    bar0: foo0, foo1, foo2, foo3; bar1: foo0, foo1, foo2, foo3</literallayout>
      </informalexample>

      <para>Have fun!</para>
    </sect2>

    <sect2 id="ebnf">
      <title>The Complete EBNF Grammar</title>

    <informalexample>
      <screen>
input      : ( TEXT
              | variable
              | START-INDEX input END-INDEX ( loop-limits )?
              )*

loop-limits: START-DELIM
                (numexp)? ',' (numexp)? ( ',' (numexp)? )?
             END-DELIM


variable   : '$' (name|expression)

expression : START-DELIM (name|variable)+
             (START-INDEX num-exp END-INDEX)?
             (':' command)* END-DELIM

name       : (VARNAME)+

command    : '-' (EXPTEXT|variable)+
           | '+' (EXPTEXT|variable)+
           | 'o' (NUMBER ('-'|',') (NUMBER)?)
           | '#'
           | '*' (EXPTEXT|variable)+
           | 's' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/'
             ('g'|'i'|'t')*
           | 'y' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/'
           | 'p' '/' NUMBER '/' (variable|SUBSTTEXT)* '/' ('r'|'l'|'c')
           | 'l'
           | 'u'

num-exp    : operand
           | operand ('+'|'-'|'*'|'/'|'%') num-exp

operand    : ('+'|'-')? NUMBER
           | CURR-INDEX
           | '(' num-exp ')'
           | variable

START-DELIM: '{'

END-DELIM  : '}'

START-INDEX: '['

END-INDEX  : ']'

CURR-INDEX : '#'

VARNAME    : '[a-zA-Z0-9_]+'

NUMBER     : '[0-9]+'

SUBSTTEXT  : '[^$/]'

EXPTEXT    : '[^$}:]+'

TEXT       : '[^$[\\]]+'
</screen>
      </informalexample>
    </sect2>

  </sect1>

  <sect1>
    <title>The &expand; Function</title>

    <para>The heart of &varexp; is the &expand; function, which is defined as
follows:</para>

    <funcsynopsis>
      <funcprototype>
        <funcdef>void <function>varexp::expand</function></funcdef>
        <paramdef>const std::string& <parameter>input</parameter></paramdef>
        <paramdef>std::string& <parameter>result</parameter></paramdef>
        <paramdef>varexp::callback_t& <parameter>lookup</parameter></paramdef>
        <paramdef>varexp::config_t* <parameter>config</parameter> = 0</paramdef>
      </funcprototype>
    </funcsynopsis>

    <para>The parameters are pretty intuitive: <parameter>input</parameter> is
obviously a reference to the input buffer in which variable expressions should
be expanded. <parameter>result</parameter> is a reference to the target buffer,
where the expanded result will be stored. The contens of
<parameter>result</parameter> will be overwritten by &expand;. It legal to
provide the same string instance for both <parameter>input</parameter> and
<parameter>result</parameter> if the original template is no longer required
after the expansion.</para>

    <para>The <parameter>lookup</parameter> parameter contains a reference to a
user-supplied class that serves as the lookup callback for accessing variable's
contents. Such a callback class must be derived from
<classname>varexp::callback_t</classname>. More details on this topic can be
found in <xref linkend="callback"> below.</para>

    <para>The last parameter, <parameter>config</parameter>, can be used to
change the lexical tokens of the parser's grammar. If you omit this parameter --
and thus pass <quote>0</quote> through the default value --, the default
configuration will be used. The default configuration is what has been used in
the examples throughout this manual; changing it will hardly be necessary. If
you want to, though, because you want to disable looping or use variables of the
form <quote>$(NAME)</quote> rather than <quote>${NAME}</quote>, please refer to
<xref linkend="config"> for a detailed discussion.</para>

    <para>In case of success, &expand; will return, otherwise, one of the
exceptions listed in <xref linkend="exceptions"> is thrown.</para>

    <sect2 id="callback">
      <title>Writing Lookup Callbacks</title>

      <para>&varexp;'s header file, <filename>varexp.hh</filename>, defines the
abstract base class <classname>varexp::callback_t</classname>, which serves as
an interface to user-supplied variable-lookup callbacks. The class is defined
like this:</para>

      <classsynopsis>
        <ooclass>
          <classname>varexp::callback_t</classname>
        </ooclass>
        <methodsynopsis>
          <modifier>virtual</modifier>
          <void>
          <methodname>operator()</methodname>
          <methodparam>
            <type>const std::string&</type>
            <parameter>name</parameter>
          </methodparam>
          <methodparam>
            <type>std::string&</type>
            <parameter>data</parameter>
          </methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <modifier>virtual</modifier>
          <void>
          <methodname>operator()</methodname>
          <methodparam>
            <type>const std::string&</type>
            <parameter>name</parameter>
          </methodparam>
          <methodparam>
            <type>int</type>
            <parameter>idx</parameter>
          </methodparam>
          <methodparam>
            <type>std::string&</type>
            <parameter>data</parameter>
          </methodparam>
        </methodsynopsis>
      </classsynopsis>

      <para>The first <function>operator()</function> is called by &expand; to
resolve a normal variable such as <quote>$NAME</quote>. The parameter
<parameter>name</parameter> will contain the name <quote>NAME</quote> in this
case, and <parameter>data</parameter> is a reference to a string where the
callback function should place the variable's contents.</para>

      <para>The second <function>operator()</function> is called to resolve an
array variable, such as <quote>${NAME[<replaceable>i</replaceable>]}</quote>.
The two parameters <parameter>name</parameter> and <parameter>data</parameter>
have the same meaning in this case, but an additional parameter is provided,
<parameter>idx</parameter>, which will contain the index
<replaceable>i</replaceable>.</para>

      <para>Either callback function may throw any exception it sees fit in case
of an error, but there are two exceptions that have a special meaning:
<exceptionname>varexp::undefined_variable</exceptionname> should be thrown by
either function in case requested variable is not defined, and the array version
of the callback should throw
<exceptionname>varexp::array_lookups_are_unsupported</exceptionname> when it has
been called but should not have been.</para>

      <para>Throwing <exceptionname>varexp::undefined_variable</exceptionname>
in case of an undefined variable is very important because in some cases this
exception will be caught by &expand; -- for example during the looping
construct! -- and changes the course of action in the routine. Any other
exception thrown by these callbacks will leave  &expand; and abort processing.
Make sure your application catches them!</para>

      <para>Sometimes it is useful to be able to determine the size of an array
in the template. &varexp; does not provide any construct that would do that,
mostly because most of the array's behavior is implementation defined anyway,
but a good convention is to have the array callback return the size of the array
in case a negative index is looked-up.</para>

      <para>In order to illustrate how to write a callback of your own, here is
a short example callback that will return variable from the Unix environment.
The source code has been taken from the test program
<filename>regression-tests/expand3.cc</filename>, so you might want to look
there for further examples of more complex callbacks.</para>

      <programlisting>using namespace std;
using namespace varexp;

struct env_lookup : public callback_t
    {
    virtual void operator()(const string&amp; name, string&amp; data)
        {
        const char* p = getenv(name.c_str());
        if (p == NULL)
            throw undefined_variable();
        else
            data = p;
        }
    virtual void operator()(const string&amp; name, int idx, string&amp; data)
        {
        throw array_lookups_are_unsupported();
        }
    };</programlisting>

    </sect2>

    <sect2 id="config">
      <title>Configuring the Parser</title>

      <para>One of the parameters passed to &expand; is a pointer to a date
structure of type <type>varexp::config_t</type>. This structure defines the
elementary tokens used by the parser to determine what is a variable expression
and what is not. The structure is defined as follows:</para>

      <classsynopsis>
        <ooclass>
          <classname>varexp::config_t</classname>
        </ooclass>
        <fieldsynopsis>
          <type>char</type>
          <varname>varinit</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>startdelim</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>enddelim</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>startindex</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>endindex</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>current_index</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char</type>
          <varname>escape</varname>
        </fieldsynopsis>
        <fieldsynopsis>
          <type>char*</type>
          <varname>namechars</varname>
        </fieldsynopsis>
        <constructorsynopsis>
          <methodname>config_t</methodname>
          <void>
        </constructorsynopsis>
      </classsynopsis>

      <para>The structure has a default constructor that will initialize the
members of the instance to the default values used throughout this
documentation:</para>

      <programlisting>varexp::config_t()
    {
    varinit       = '$';
    startdelim    = '{';
    enddelim      = '}';
    startindex    = '[';
    endindex      = ']';
    current_index = '#';
    escape        = '\\;
    namechars     = "a-zA-Z0-9_";
    }
</programlisting>

      <para>If want to use this default configuration, don't mess with a
<type>varexp::config_t</type> structure at all; passing <quote>0</quote> to
&expand; or leaving <parameter>config</parameter> out entirely will use exactly
this configuration. If you want to parse a different syntax than the default,
though, get a local instance of the <type>varexp::config_t</type> class, modify
those values, and pass a pointer to the instance into &expand;.</para>

      <para>The members of the structure have the following meaning:</para>

      <variablelist>
        <varlistentry>
          <term><varname>varinit</varname></term>
          <listitem>
            <para>This character defines the character that starts a variable in
the input text.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>startdelim</varname></term>
          <term><varname>enddelim</varname></term>
          <listitem>
            <para>These variables define the characters which must be used to
delimit a complex variable expression.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>startindex</varname></term>
          <term><varname>endindex</varname></term>
          <listitem>
            <para>These character define the characters used to delimit both an
index specification to an array variable and the start and end delimiter of the
looping construct. You may set these entries to <quote>0</quote> in order to
disable array support and looping altogether.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>current_index</varname></term>
          <listitem>
            <para>This entry defines the character to be replaced by the current
loop counter in an index specification.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>escape</varname></term>
          <listitem>
            <para>This entriy defines the character that will espace a
<quote>varinit</quote> or <quote>startindex</quote> character in the input text
so that &expand; interprets it literally and not as a special.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>namechars</varname></term>
          <listitem>
            <para>This string defines the set of characters that are legal for a
variable name. The specification may contain character ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Please note that it is possible to shoot yourself in the foot with
an incorrect parser configuration. The <varname>namechars</varname> entry, for
example, must not contain any of the specials defined above or the parser will
not be able to determine the end of a variable expression anymore. There is a
set of consistency checks that will be run by &expand;, which will throw an
<exceptionname>varexp::invalid_configuration</exceptionname> exception in case
the configuration is errorneous, but these checks will probably not catch all
configurations that don't make sense. So better be careful when defininig your
own configuration for the parser.</para>
    </sect2>

  </sect1>

  <sect1>
    <title>The &unescape; Function</title>

    <para>The missing piece in &varexp; is the &unescape; function. It will
expand the quoted pairs described in <xref linkend="quoted-pairs">. Its
prototype, as defined in <filename>varexp.hh</filename> is:</para>

    <funcsynopsis>
      <funcprototype>
        <funcdef>void <function>varexp::unescape</function></funcdef>
        <paramdef>const std::string& <parameter>input</parameter></paramdef>
        <paramdef>std::string& <parameter>result</parameter></paramdef>
        <paramdef>bool <parameter>unescape_all</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>

    <para>The parameters <parameter>input</parameter> and
<parameter>result</parameter> are references to the input and output buffer
respectively. It is legal to pass the same <type>std::string</type> instance as
input and output if the original buffer isn't required anymore. The third
parameter, <parameter>unescape_all</parameter> will determine whether &unescape;
should expand only the <emphasis>known</emphasis> quoted pairs or whether it
should expand <emphasis>all</emphasis> quoted pairs.</para>

    <para>If this parameter is set to <literal>false</literal>, only the quoted
pairs described in <xref linkend="quoted-pairs"> are expanded; all other quoted
pairs -- the <quote>unknown</quote> ones -- will be left untouched. If
<parameter>unescape_all</parameter> is set to <literal>true</literal>, though,
any combination of <quote>\<replaceable>a</replaceable></quote> will be expanded
to <quote><replaceable>a</replaceable></quote>.</para>

    <para>You will need this parameter if you want to combine &unescape; with
&expand;, because an input buffer might contain unknown quoted pairs that have a
special meaning to variable constructs! One example is the quoted pair
<quote>\1</quote>, which is used in regular expression search-and-replace.
Another example is the string <quote>\${Not an variable}</quote>. These quoted
pairs must be preserved for &expand;, so the usual approach for combining
&unescape; und &expand; is to call the functions in the following order:</para>

    <procedure>
      <step>
        <para>Call &unescape; with <parameter>unescape_all</parameter> set to
<literal>false</literal>.</para>
      </step>
      <step>
        <para>Call &expand; on the resulting buffer.</para>
      </step>
      <step>
        <para>Call &unescape; on the resulting buffer with
<parameter>unescape_all</parameter> set to <literal>true</literal>.</para>
      </step>
    </procedure>

    <para>This approach is illustrated in the example program shown in <xref
linkend="example">.</para>

    <para>&unescape; will return if no error occured. If the input buffer
contained syntax errors, the apropriate exception as described in <xref
linkend="exceptions"> will be thrown.</para>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions Thrown by &varexp;</title>

    <para>&varexp; throws various exceptions in case of a syntax error or when
required system resources (memory) cannot be reserved. The complete list is
found below. In addition to these, &varexp; may throw practically any of the
exceptions thrown by the STL's containers.</para>

    <para>All of the following exceptions are derived from the abstract base
class <exceptionname>varexp::error</exceptionname>, so by catching this
exception, you can catch all of them. The
<exceptionname>varexp::error</exceptionname> exception provides the following
interface:</para>

    <classsynopsis>
      <ooclass>
        <classname>varexp::error : public std::runtime_error</classname>
      </ooclass>
      <constructorsynopsis>
        <methodname>error</methodname>
        <methodparam>
          <type>const std::string&</type>
          <parameter>what_msg</parameter>
        </methodparam>
      </constructorsynopsis>
      <methodsynopsis>
        <modifier>virtual</modifier>
        <type>const char*</type>
        <methodname>what</methodname>
        <void>
      </methodsynopsis>
      <fieldsynopsis>
        <type>size_t</type>
        <varname>current_position</varname>
      </fieldsynopsis>
    </classsynopsis>

    <para>As you can see, <exceptionname>varexp::error</exceptionname> is
derived from <exceptionname>std::runtime_error</exceptionname>. This inheritance
relationship also defines the <function>what</function> member function that
will return a short, clear-text description of the error that caused the actual
execption instance to be thrown. In addition to this member funcition, the
member variable <varname>current_position</varname> is available, which contains
the offset position in the input buffer that was parsed when the error
occured.</para>

    <para>Here is the complete list of all &varexp;-specific exceptions:</para>

    <variablelist>
      <varlistentry>
        <term><exceptionname>varexp::incomplete_hex</exceptionname></term>
        <listitem>
          <para>The input buffer ended before a hexadecimal
<quote>\x<replaceable>aa</replaceable></quote> quoted pair was complete.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_hex</exceptionname></term>
        <listitem>
          <para>Any of the <replaceable>a</replaceable> characters in an
<quote>\x<replaceable>aa</replaceable></quote> quoted pair was not a valid
hexadecimal character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::octal_too_large</exceptionname></term>
        <listitem>
          <para>The first digit of an octal
<quote>\<replaceable>abb</replaceable></quote> quoted pair was not in the range
from 0 to 3.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_octal</exceptionname></term>
        <listitem>
          <para>A digit of an octal
<quote>\<replaceable>abb</replaceable></quote> expression was not in the range
from 0 to 7.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incomplete_octal</exceptionname></term>
        <listitem>
          <para>The input buffer ended in the before an octal
<quote>\<replaceable>abb</replaceable></quote> quoted pair was complete.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incomplete_grouped_hex</exceptionname></term>
        <listitem>
          <para>A hexadecimal
<quote>\x{<replaceable>&hellip;</replaceable>}</quote> expression contained an
odd number of characters in the <replaceable>&hellip;</replaceable>
parameter.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incorrect_class_spec</exceptionname></term>
        <listitem>
          <para>In a character range specification
<quote><replaceable>a</replaceable>-<replaceable>b</replaceable></quote>, the
start of the range <replaceable>a</replaceable> was <quote>bigger</quote> (in
terms of the ASCII code) than the end of the range
<replaceable>b</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_configuration</exceptionname></term>
        <listitem>
          <para>&expand;'s configuration is inconsistent.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incomplete_variable_spec</exceptionname></term>
        <listitem>
          <para>Either, the input buffer ended right after a variable
initializer token (<quote>$</quote>) was found, or a complex variable expression
was not correctly terminated, meaning, that the closing <quote>}</quote> bracket
was missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::undefined_variable</exceptionname></term>
        <listitem>
          <para>This exception is supposed to be thrown by the user-provided
callback when an unknown variable is requested.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::input_isnt_text_nor_variable</exceptionname></term>
        <listitem>
          <para>This exception is throw in the rather unlikely case that the
parser could not process the complete buffer, yet no error occured. When this
should happen? Well, not at all. But since the error is theoretically possible,
I defined it.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::unknown_command_char</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:<replaceable>c</replaceable>}</quote>
expression, <replaceable>c</replaceable> was none of the supported
operations.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::malformatted_replace</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:s&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::unknown_replace_flag</exceptionname></term>
        <listitem>
          <para>An unsupported flag was provided in an
<quote>${NAME:s&hellip;}</quote> expression.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_regex_in_replace</exceptionname></term>
        <listitem>
          <para>The regular expression given as pattern in an
<quote>${NAME:s&hellip;}</quote> expression failed to compile.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::missing_parameter_in_command</exceptionname></term>
        <listitem>
          <para>The required <replaceable>word</replaceable> parameter was
missing in an <quote>${NAME:-<replaceable>word</replaceable>}</quote>,
<quote>${NAME:+<replaceable>word</replaceable>}</quote>, or
<quote>${NAME:*<replaceable>word</replaceable>}</quote> expression.
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::empty_search_string</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:s&hellip;} expression, the
<replaceable>search</replaceable> parameter was empty.</quote>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::missing_start_offset</exceptionname></term>
        <listitem>
          <para>The <replaceable>start</replaceable> parameter was missing in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
expression.</para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><exceptionname>varexp::invalid_offset_delimiter</exceptionname></term>
        <listitem>
          <para>In an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression, the delimiter between <replaceable>start</replaceable> and
<replaceable>end</replaceable> was neither a <quote>,</quote> nor a
<quote>-</quote>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::range_out_of_bounds</exceptionname></term>
        <listitem>
          <para>The <replaceable>stop</replaceable> parameter in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression exceeded the actual length of the string.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::offset_out_of_bounds</exceptionname></term>
        <listitem>
          <para>The <replaceable>start</replaceable> parameter in an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
or
<quote>${NAME:o<replaceable>start</replaceable>-<replaceable>end</replaceable>}</quote>
expression exceeded the actual length of the string.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::offset_logic</exceptionname></term>
        <listitem>
          <para>In an
<quote>${NAME:o<replaceable>start</replaceable>,<replaceable>end</replaceable>}</quote>
expression, <replaceable>start</replaceable> was larger than
<replaceable>stop</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::malformatted_transpose</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:y&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::transpose_classes_mismatch</exceptionname></term>
        <listitem>
          <para>The <replaceable>ochars</replaceable> range has not the same
number of characters as the <replaceable>nchars</replaceable> range in an
<quote>${NAME:y&hellip;}</quote> expression.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::empty_transpose_class</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:y&hellip;}</quote> expression, either the
<replaceable>ochars</replaceable> or the <replaceable>nchars</replaceable> range
was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incorrect_transpose_class_spec</exceptionname></term>
        <listitem>
          <para>In a character range given in an
<quote>${NAME:y&hellip;}</quote> expression, the start of the range was larger
(in terms of the ASCII code) than the end character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::malformatted_padding</exceptionname></term>
        <listitem>
          <para>In an <quote>${NAME:p&hellip;}</quote> expression, one of the
required parameters is missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::missing_padding_width</exceptionname></term>
        <listitem>
          <para>The <replaceable>width</replaceable> parameter in an
<quote>${NAME:p&hellip;}</quote> expression was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::empty_padding_fill_string</exceptionname></term>
        <listitem>
          <para>The <replaceable>fill</replaceable> parameter in an
<quote>${NAME:p&hellip;}</quote> expression was empty.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::unknown_quoted_pair_in_replace</exceptionname></term>
        <listitem>
          <para>In the <replaceable>replace</replaceable> parameter of an
<quote>${NAME:s&hellip;}</quote> expression, an invalid quoted pair was
specified. Valid are only quoted pairs of the form
<quote>\<replaceable>digit</replaceable></quote>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::submatch_out_of_range</exceptionname></term>
        <listitem>
          <para>In the <replaceable>replace</replaceable> parameter an
<quote>${NAME:s&hellip;}</quote> expression, a submatch with a number greater
than the number of submatches defined in the <replaceable>search</replaceable>
parameter was accessed.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incomplete_quoted_pair</exceptionname></term>
        <listitem>
          <para>The input buffer ended right after a backslash character.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::array_lookups_are_unsupported</exceptionname></term>
        <listitem>
          <para>This exception is supposed to be thrown by the user-supplied
callback when the array lookup function is called even though arrays should not
occur. If you don't intend to support arrays, though, you should disable them
via the parser's configuration instead.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_char_in_index_spec</exceptionname></term>
        <listitem>
          <para>The index specification of array variable contains an invalid
character, a character that is not part of a <literal>num-exp</literal> that
is.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::incomplete_index_spec</exceptionname></term>
        <listitem>
          <para>The input buffer ended in an open variable index specification;
meaning that the terminating <quote>]</quote> delimiter was missing.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::unclosed_bracket_in_index</exceptionname></term>
        <listitem>
          <para>An arithmetic group in an index specification was closed
properly with a <quote>)</quote> bracket.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::division_by_zero_in_index</exceptionname></term>
        <listitem>
          <para>Division by zero error in index specification.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::unterminated_loop_construct</exceptionname></term>
        <listitem>
          <para>The buffer ended in the midst of on open looping
construct.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><exceptionname>varexp::invalid_char_in_loop_limits</exceptionname></term>
        <listitem>
          <para>The looping limits specification of contained invalid
characters.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1 id="example">
    <title>Example Program</title>

    <para>The following source code may be found in
<filename>regression-test/expand5.cc</filename>. You might want to check the
other test programs there for more complex examples. Especially
<filename>expand6.cc</filename>, which also makes use of arrays and
loops!</para>

    <programlisting>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cerrno&gt;
#include &lt;cstring&gt;
#include "../varexp.hh"
using namespace varexp;
using namespace std;

struct env_lookup : public callback_t
    {
    virtual void operator()(const string&amp; name, string&amp; data)
        {
        const char* p = getenv(name.c_str());
        if (p == NULL)
            throw undefined_variable();
        else
            data = p;
        }
    virtual void operator()(const string&amp; name, int idx, string&amp; data)
        {
        throw runtime_error("Not implemented.");
        }
    };

int main(int argc, char** argv)
    {
    const char* input =                            \
        "\\$HOME      = '${HOME}'\\n"              \
        "\\$OSTYPE    = '${$FOO${BAR}}'\\n"        \
        "\\$TERM      = '${TERM}'\\n";
    const char* output =                           \
        "$HOME      = '/home/regression-tests'\n"  \
        "$OSTYPE    = 'regression-os'\n"           \
        "$TERM      = 'regression-term'\n";
    string tmp;
    env_lookup lookup;

    if (setenv("HOME", "/home/regression-tests", 1) != 0 ||
        setenv("OSTYPE", "regression-os", 1) != 0 ||
        setenv("TERM", "regression-term", 1) != 0 ||
        setenv("FOO", "OS", 1) != 0 ||
        setenv("BAR", "TYPE", 1) != 0)
        {
        printf("Failed to set the environment: %s.\n",
               strerror(errno));
        return 1;
        }
    unsetenv("UNDEFINED");

    expand(input, tmp, lookup);
    unescape(tmp, tmp, true);

    if (tmp != output)
        {
        printf("The buffer returned by var_expand() " \
               "is not what we expected.\n");
        return 1;
        }

    return 0;
    }</programlisting>

  </sect1>

  <sect1>
    <title>License</title>

    <para>This library is based on the OSSP var library, which I developed for
Cable &amp; Wireless Deutschland. I hereby grant permission to use all files
included in this distribution under the same terms as the original
version:</para>

    <literallayout>    Copyright (c) 2002 Peter Simons &lt;simons@computer.org&gt;
    Copyright (c) 2001 The OSSP Project (http://www.ossp.org/)
    Copyright (c) 2001 Cable & Wireless Deutschland (http://www.cw.com/de/)

    Permission to use, copy, modify, and distribute this software for
    any purpose with or without fee is hereby granted, provided that
    the above copyright notice and this permission notice appear in all
    copies.

    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHORS AND COPYRIGHT HOLDERS AND THEIR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.</literallayout>
  </sect1>

</article>

<!--
Local Variables:
mode: sgml
fill-column:80
End:
-->

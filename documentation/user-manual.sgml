<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY version SYSTEM "../VERSION">
<!ENTITY varexp "<application>libvarexp</application>">
<!ENTITY unescape "<function>unescape</function>">
<!ENTITY expand "<function>expand</function>">
<!ENTITY sh "<citerefentry><refentrytitle>sh</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY make "<citerefentry><refentrytitle>make</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
<!ENTITY perl "<citerefentry><refentrytitle>perl</refentrytitle><manvolnum>1</manvolnum></citerefentry>">
]>

<article lang="en">
  <articleinfo>
    <title>Variable Expression Library &version;</title>
    <author>
      <firstname>Peter</firstname>
      <surname>Simons</surname>
      <affiliation>
        <address><email>simons@computer.org</email></address>
      </affiliation>
    </author>
  </articleinfo>

  <sect1>
    <title>Purpose of this Library</title>

    <para>&varexp; is a C++ library that allows its users to detach any kind of
information from the representation of that information by providing a
simple-to-use but powerful text-template mechanism. Similar mechanisms have been
available in tools like &sh;, &make;, or &perl; forever and have proven to be
very useful. The basic idea is that the relevant information is made available
in variables, which the author of the template can than use within the text
itself as he or she sees fit.</para>

    <para>Consider, for example, a tool that will calculate the monthly
financial reports of a small company. Such a program should only
<emphasis>calculate</emphasis> the required values, it should not worry about
writing the resulting reports into an HTML file, a CSV file, or whatever format
is desired. Instead, it should make the results of the calculation available in
the variables <quote>$TURNOVER</quote>, <quote>$PROFIT</quote>, and
<quote>$INCREASE</quote>. Then, using &varexp;, it could load an arbitrary
template file and have the actual values inserted at the apropriate positions.
Without changing a single line of code, one could generate the monthly report in
HTML:</para>

    <informalexample>
      <screen>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Financial Report&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;h1&gt;Financial report&lt;/h1&gt;

    &lt;p&gt;This month, our glorious company reached a
total turnover of $(TOTAL) Euros, totalling $(PROFIT)
Euros before taxes. That means we have increased our
profit by $(INCREASE) percent compared to last
month.&lt;/p&gt;

  &lt;/body&gt;
&lt;/html&gt;</screen>
    </informalexample>

    <para>Or you can send it out as a plain-text e-mail:</para>

    <informalexample>
      <screen>From: nobody@example.org (Monthly Financial Data)
Subject: This month's financial report

Dear Colleagues,

we have earned a total of $(PROFIT) Euros this month!
This means that we have increased profits by $(PROFIT)
percent compared to last month, totalling a turnover
of $(TURNOVER) of Euros.

Sincerely yours,
    The Statistics Program</screen>
    </informalexample>

    <para>Even better, by using such templates to generate the output you are
effectively independent of the language you choose! The last report, for
example, could also read:</para>

    <informalexample>
      <screen>From: nobody@example.org (Grssss&ouml;tmpf!)
Subject: Ajahaha Mzoodeutschmark

Nuwarskvu,

Quhu&szlig;aour Maou Ahosetuh Cravullitstziki Nakaou $(PROFIT)
Akqiss&auml;e&uuml;&szlig; Blaga: $(TURNOVER) Stauhr $(INCREASE)!!!!</screen>
    </informalexample>

    <para>This version is -- as you can probably easily recognize -- in
German.</para>

    <para>&varexp; offers application developers two functions, that will do all
this for them, plus, the end-user has <emphasis>numerous</emphasis> ways not
only to insert variables into his template files but to modify the variables
contents on the fly, do full-blown regular expression search-and-replaces, or
loop over the contents of arrays of variables.</para>

    <para>Furthermore, the parser included in &varexp; can be re-configured to
use tokens different from the ones shown in the examples; one could as well use
<quote>%{NAME}</quote>, change the set of allowed characters for variable names,
etc.</para>

    <para>And last but certainly not least, these variables are not limited to
<quote>environment variables</quote> at all. The programmer is free to provide a
callback function to &varexp; that will be used to map a variable name to its
contents. Thus, the variables your application provides, can reside internally
completely. In fact, they can reside pretty much anywhere you want and they
contain pretty much anything you want, as long as <emphasis>you</emphasis> write
the callback.</para>

  </sect1>

  <sect1>
    <title>Expressions Supported by the Library</title>

    <sect2>
      <title>Variable Expressions</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Quoted Pairs</title>

      <para>The &unescape; function knows the following quoted pairs:</para>

      <variablelist>
        <varlistentry>
          <term><symbol>\t</symbol></term>
          <term><symbol>\r</symbol></term>
          <term><symbol>\n</symbol></term>
          <listitem>
            <para>These expressions are replaced by the appropriate binary
representation of a tab, a carrige return and a newline respectively.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>\<replaceable>abc</replaceable></term>
          <listitem>
            <para>This expression is replaced by the value of the octal number
<replaceable>abc</replaceable>. Valid digits of <replaceable>a</replaceable> are
in the range of 0' to 3, for digits <replaceable>b</replaceable> and
<replaceable>c</replaceable> in the range of 0 to 7. Please note that an octal
expression is recognized only if the backslash is followed by
<emphasis>three</emphasis> digits! The expression <literal>\1a7</literal>, for
example, is interpreted as the quoted pair <literal>\1</literal> followed by the
verbatim text <literal>a7</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x<replaceable>ab</replaceable></symbol></term>
          <listitem>
            <para>This expression is replaced by the value of the hexadecimal
number $<replaceable>ab</replaceable>. Both characters
<replaceable>a</replaceable> and <replaceable>b</replaceable> must be in the
range of 0 to 9, a to f, or A to F.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><symbol>\x{&hellip;}</symbol></term>
          <listitem>
            <para>This expression denotes a set of grouped hexadecimal
numbers. The <replaceable>&hellip;</replaceable> part may consist of an
arbitrary number of hexadecimal pairs, such as in <literal>\x{}</literal>,
<literal>\x{ff}</literal>, or <literal>\x{55ffab04}</literal>. The empty
expression <literal>\x{}</literal> is a no-op; it will not produce any
output.</para>

            <para>This construct may be useful to specify multi-byte characters
(as in Unicode). Even though <literal>\x{0102}</literal> is effectively
equivalent to <literal>\x01\x02</literal>, the grouping of values may be useful
in other contexts, even though <function>unescape()</function> or
<function>expand()</function> make no direct use of it.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>The Complete EBNF Grammar</title>
      <para></para>
    </sect2>

  </sect1>

  <sect1>
    <title>The &expand; Function</title>
    <para></para>
  </sect1>

  <sect1>
    <title>The &unescape; Function</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Example Program</title>
    <para></para>
  </sect1>

  <sect1>
    <title>License</title>

    <para>This library is based on the OSSP var library, which I developed for
Cable &amp; Wireless Deutschland. I hereby grant permission to use all files
included in this distribution under the same terms as the original
version:</para>

    <literallayout>    Copyright (c) 2002 Peter Simons &lt;simons@computer.org&gt;
    Copyright (c) 2001 The OSSP Project (http://www.ossp.org/)
    Copyright (c) 2001 Cable & Wireless Deutschland (http://www.cw.com/de/)

    Permission to use, copy, modify, and distribute this software for
    any purpose with or without fee is hereby granted, provided that
    the above copyright notice and this permission notice appear in all
    copies.

    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHORS AND COPYRIGHT HOLDERS AND THEIR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.</literallayout>
  </sect1>

<!--
  <refsect1>
    <title>Supported Variable Expressions</title>

    <para>In addition to the ordinary variable expansion of
<literal>$name</literal> or <literal>${name}</literal>,
<function>expand()</function> supports a number of operations that can be
performed on the contents of <literal>name</literal> before it is copied to the
output buffer. Such operations are always denoted by appending the a colon and a
command character to the variable name, for expample:
<literal>${name:l}</literal> or <literal>${name:s/foo/bar/}</literal>. You can
specify multiple operations, which are executed from the left to the right, for
expample: <literal>${name:l:s/foo/bar/:u}</literal>.</para>

    <para>Also, you can nest variable expansion and command execution pretty
much anywhere in the construct, for example: ${name:s/$foo/$bar/g}. In that
context is probably useful to have a look at the formal expression grammar
provided in section <citetitle pubwork="section">EBNF Grammar of Supported
Expressions</citetitle>.</para>

    <para>Generally, all operations described below do not modify the contents
of any variable - - <function>expand()</function> generally can't set variables,
it will only read them. If the description says that an operation
<quote>replaces the contents of variable <literal>$foo</literal></quote>, it is
meant that rather than expanding the expression the the contents of
<literal>$foo</literal>, it will expand to the modified string instead. The
contents of <literal>$foo</literal> is left untouched in any case.</para>

    <variablelist>
      <varlistentry>
        <term><literal>${name:#}</literal></term>
        <listitem>
          <para>This operation will expand to the length of the contents of
<literal>$name</literal>. If, for example, <literal>$FOO</literal> is
<literal>foobar</literal>, then <literal>${FOO:#}</literal> will result in
<literal>6</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:l}</literal></term>
        <listitem>
          <para>This operation will turn the contents of
<literal>$name</literal> to all lower-case, using the system routine
<citerefentry> <refentrytitle>tolower</refentrytitle> <manvolnum>3</manvolnum>
</citerefentry>, thereby possibly using the system's localization
settings.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:u}</literal></term>
        <listitem>
          <para>This operation will turn the contents of
<literal>$name</literal> to all upper-case, using the system routine
<citerefentry> <refentrytitle>toupper</refentrytitle> <manvolnum>3</manvolnum>
</citerefentry>, thereby possibly using the system's localization
settings.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:*&lt;word&gt;}</literal></term>
        <listitem>
          <para>This operation will replace the contents of
<literal>$name</literal> with the empty string (<literal>""</literal>) if
<literal>$name</literal> is not empty. Otherwise, it will replace it by
<literal>word</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:-&lt;word&gt;}</literal></term>
        <listitem>
          <para>This operation will replace the contents of
<literal>$name</literal> with <literal>word</literal> if
<literal>$name</literal> is empty. Otherwise, it will expand to the contents of
<literal>$name</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:+&lt;word&gt;}</literal></term>
        <listitem>
          <para>This operation will replace the contents of
<literal>$name</literal> with <literal>word</literal> if
<literal>$name</literal> is not empty. Otherwise, it will expand to the contents
of <literal>$name</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:o&lt;start&gt;,&lt;end&gt;}</literal></term>
        <listitem>
          <para>This operation will cut the string starting at position "start"
            to ending position "end" out of the contents of
            <literal>$name</literal> and return that. Please note that the
            character at position "end" is included in the result; ${name:o3,4}
            for instance, will return a two-character string. Also, please note
            that start positions begin at zero (0)! If the "end" parameter is
            left out, as in ${name:o3,}, the operation will return the string
            starting at position 3 until the end.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:o&lt;start&gt;-&lt;length&gt;}</literal></term>
        <listitem>
          <para>This operation will cut the range of "start" to "end" out of the
            contents of <literal>$name</literal> and return that. ${name:o3-4}
            means, for instance, to return the next 4 charaters starting at
            position 3 in the string. Please note that start positions begin at
            zero (0)! If the "end" range is left out, as in ${name:o3-}, the
            operation will return the string starting at position 3 until the
            end.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:s/&lt;pattern&gt;/&lt;string&gt;/[gti]}</literal></term>
        <listitem>
          <para>This operation will perform a search-and-replace operation on
            the contents of <literal>$name</literal> and return the result. The
            behavior of the search-and-replace is modified by the following
            flags parameter: If a 't' flag has been provided, a plain text
            search-and-replace is performed, otherwise, the default is to a
            regular expression search-and-replace as in the system utility
            sed(1). If the 'g' flag has been provided, the search-and-replace
            will replace all instances of "pattern" by "replace", otherwise, the
            default is to replace only the first instance. If the 'i' flag has
            been provided, the search-and-replace will take place
            case-insensitively, otherwise, the default is to distinguish
            character case.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:y/&lt;ochars&gt;/&lt;nchars&gt;/}</literal></term>
        <listitem>
          <para>This operation will translate all characters in the contents of
            <literal>$name</literal> that are found in the "ochars" class to the
            corresponding character in the "nchars" class, just like the system
            utility tr(1) does. Both "ochars" and "nchars" may contain character
            range specifications, for example "a-z0-9". A hyphon as the first or
            last character of the class specification is interpreted literally.
            Both the "ochars" and the "nchars" class must contain the same
            number of characters after all ranges are expanded, or <function>expand()</function> will
            abort with an error.</para>

          <para> If, for example, <literal>$FOO</literal> would contain
            "foobar", then <literal>${FOO:y/a-z/A-Z/}</literal> would yield
            "FOOBAR". Another goodie is to use that operation to ROT13-encrypt
            or decrypt a string with the expression
            "${FOO:y/a-z/n-za-m/}".</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>${name:p/&lt;width&gt;/&lt;string&gt;/&lt;align&gt;}</literal></term>
        <listitem>
          <para>This operation will pad the contents of <literal>$name</literal>
            with "string" according to the "align" parameter, so that the result
            is at least "width" characters long. Valid parameters for align are
            'l' (left), 'r' (right), or 'c' (center). The "string" parameter may
            contain multiple characters, if you see any use for that.</para>

          <para>If, for example, "$FOO" is "foobar", then "${FOO:p/20/./c}"
            would yield ".......foobar......."; "${FOO:p/20/./l}" would yield
            "foobar.............."; and "${FOO:p/20/./r}" would yield
            "..............foobar";</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>EBNF Grammar of Supported Expressions</title>

    <informalexample>
      <screen>
 input      : ( TEXT | variable | START-INDEX input END-INDEX ( loop-limits )? )*

 loop-limits: START-DELIM (numexp)? ',' (numexp)? ( ',' (numexp)? )? END-DELIM

 variable   : '$' (name|expression)

 expression : START-DELIM (name|variable)+ (START-INDEX num-exp END-INDEX)? (':' command)* END-DELIM

 name       : (VARNAME)+

 command    : '-' (EXPTEXT|variable)+
            | '+' (EXPTEXT|variable)+
            | 'o' (NUMBER ('-'|',') (NUMBER)?)
            | '#'
            | '*' (EXPTEXT|variable)+
            | 's' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/' ('g'|'i'|'t')*
            | 'y' '/' (variable|SUBSTTEXT)+ '/' (variable|SUBSTTEXT)* '/'
            | 'p' '/' NUMBER '/' (variable|SUBSTTEXT)* '/' ('r'|'l'|'c')
            | 'l'
            | 'u'

 num-exp    : operand
            | operand ('+'|'-'|'*'|'/'|'%') num-exp

 operand    : ('+'|'-')? NUMBER
            | CURR-INDEX
            | '(' num-exp ')'
            | variable

 START-DELIM: '{'

 END-DELIM  : '}'

 START-INDEX: '['

 END-INDEX  : ']'

 CURR-INDEX : '#'

 VARNAME    : '[a-zA-Z0-9_]+'

 NUMBER     : '[0-9]+'

 SUBSTTEXT  : '[^$/]'

 EXPTEXT    : '[^$}:]+'

 TEXT       : '[^$[\\]]+'
      </screen>
    </informalexample>

    <para>Please note that the descriptions of START-DELIM, END-DELIM, VARNAME,
      SUBSTEXT, and EXPTEXT shown here assume that <function>expand()</function> has been called in
      the default configuration. In thruth, the contents of VARNAME corresponds
      directly to the setting of "namechars" in the config_t structure.
      Similarly, the dollar ('$') corresponds directly to the setting of
      "varinit", and the '{' and '}' characters to "startdelim" and "enddelim"
      respectively.</para>
  </refsect1>

  <refsect1>
    <title>Codes Returned by the Library</title>

    <para>Generally, all routines part of that library follow the convention
      that a return code of zero or greater denotes success and a return code of
      less than zero denotes failure. (This is slightly different for the
      callbacks, please see section "THE LOOKUP CALLBACK" for further details.)
      In order to distinguish the various causes of failure, the following set
      of defines is provided in <filename>var.h</filename>:</para>

=over 4

=item OK

No errors; everything went fine.

=item ERR_INCOMPLETE_QUOTED_PAIR

The configured escape character as the last character in the input
buffer.

=item ERR_INVALID_ARGUMENT

Any of the provided arguments is invalid, for expample: the pointer to
the input buffer is NULL.

=item ERR_SUBMATCH_OUT_OF_RANGE

During execution of a ${name:s/pattern/replace/flags} operation, a
submatch has been referenced in the "replace" part, which's number is
greater than the number of submatches encountered in the "pattern"
part, for expample: ${name:s/foo(bar)/\\2/}.

=item ERR_UNKNOWN_QUOTED_PAIR_IN_REPLACE

During execution of a ${name:s/pattern/replace/flags} operation, the
parser encountered an unknown quoted pair in the "replace" part. Valid
quoted pairs are "\\\\", "\\0", "\\1", ... , "\\9" only.

=item ERR_EMPTY_PADDING_FILL_STRING

The "fill" part in an ${name:p/width/fill/pos/} expression was found
to be empty.

=item ERR_MISSING_PADDING_WIDTH

The "width" part in an ${name:p/width/fill/pos/} expression was found
to be empty.

=item ERR_MALFORMATTED_PADDING

Any of the "/" delimiters was missing while parsing a
${name:p/width/fill/pos/} expression.

=item ERR_INCORRECT_TRANSPOSE_CLASS_SPEC

While parsing a ${name:y/old-class/new-class/} expression, any of the
character class specifications had a start-of-range character that was
greater (in terms of ASCII encoding) than the end-of-range character,
for expample: "[z-a]".

=item ERR_EMPTY_TRANSPOSE_CLASS

While parsing a ${name:y/old-class/new-class/} expression, any of the
character class specifications was found to be empty.

=item ERR_TRANSPOSE_CLASSES_MISMATCH

While parsing a ${name:y/old-class/new-class/} expression, the number
of characters found in the expanded "old-class" was different than the
number of characters in new-class".

=item ERR_MALFORMATTED_TRANSPOSE

Any of the "/" delimiters was missing while parsing a
${name:y/old-class/new-class/} expression.

=item ERR_OFFSET_LOGIC

The "end" offset in a ${name:o&lt;start&gt;,&lt;end&gt;} expression is smaller
than the "start" offset.

=item ERR_OFFSET_OUT_OF_BOUNDS

The "start" offset in a ${name:o&lt;start&gt;,&lt;end&gt;} expression is greater
than the number of characters found in <literal>$name</literal>.

=item ERR_RANGE_OUT_OF_BOUNDS

The end-of-range in a ${name:o&lt;start&gt;,&lt;end&gt;} or ${name:o&lt;start&gt;-&lt;end&gt;}
expression would be greater than the number of characters found in
<literal>$name</literal>.

=item ERR_INVALID_OFFSET_DELIMITER

The two numbers in an offset operation are delimited by a character
different from "," or "-".

=item ERR_MISSING_START_OFFSET

The "start" offset in a ${name:o&lt;start&gt;,&lt;end&gt;} or
${name:o&lt;start&gt;-&lt;end&gt;} expression was found to be empty.

=item ERR_EMPTY_SEARCH_STRING

The "pattern" part of a ${name:s/pattern/replace/flags} expression was
found to be empty.

=item ERR_MISSING_PARAMETER_IN_COMMAND

In a ${name:+word}, ${name:-word}, or ${name:*word} expression, the
<literal>word</literal> part was missing - that means empty.

=item ERR_INVALID_REGEX_IN_REPLACE

While compiling the "pattern" part of a
${name:s/pattern/replace/flags} expression, regcomp(3) failed with an
error.

=item ERR_UNKNOWN_REPLACE_FLAG

In a ${name:s/pattern/replace/flags} expression, a flag other that
"t", "i", or "g" was found.

=item ERR_MALFORMATTED_REPLACE

Any of the "/" delimiters was missing while parsing a
${name:s/pattern/replace/flags} expression.

=item ERR_UNKNOWN_COMMAND_CHAR

In a ${name:<char>} expression, "char" did not specify any of the
supported operations.

=item ERR_INPUT_ISNT_TEXT_NOR_VARIABLE

At one point during parsing of the input buffer, an expression was
found that was neither verbatim text nor a variable expression. This
usually is the result of a inconsistent configuration of <function>expand()</function>
via the config_t paramater.

=item ERR_UNDEFINED_VARIABLE

Looking up a variable's contents failed and <function>expand()</function> was running
in "force expand" mode.

=item ERR_INCOMPLETE_VARIABLE_SPEC

The input buffer ended in the middle of a ${name} expression, or the
configured variable initializer character was found to be the last
character of the input buffer.

=item ERR_OUT_OF_MEMORY

<function>expand()</function> failed while malloc(3)ing internally needed buffers.

=item ERR_INVALID_CONFIGURATION

Any of the characters configured in the config_t structure as a
special ("varinit", "startdelim", "enddelim", and "escape") was found
to be a member of the "namechars" class.

=item ERR_INCORRECT_CLASS_SPEC

The character class specification "namechars" of the config_t
structure provided to expand was syntactically incorrect, that is,
the start-of-range was greater than end-of-range. (See also
ERR_INCORRECT_TRANSPOSE_CLASS_SPEC.)

=item ERR_INCOMPLETE_GROUPED_HEX

<function>unescape()</function> encountered the end of the input buffer in the middle
of a grouped-hex "\\x{...}" expression.

=item ERR_INCOMPLETE_OCTAL

<function>unescape()</function> encountered the end of the input buffer in the middle
of an octal "\\000" expression.

=item ERR_INVALID_OCTAL

The second of third digit of an octal "\\000" expression was found not
be in the range of '0' to '7'.

=item ERR_OCTAL_TOO_LARGE

The value specified via an octal "\\000" expression was larger than
0377.

=item ERR_INVALID_HEX

Any of the digits of a hex "\\x00" expression was found not be in the
range of '0' to '9' or 'a' to 'b'.

=item ERR_INCOMPLETE_HEX

<function>unescape()</function> encountered the end of the input buffer in the middle
of a hex "\\x00" expression.

=item ERR_INCOMPLETE_NAMED_CHARACTER

<function>unescape()</function> encountered the backslash ('\\') as the last character
of the input buffer.

=item ERR_ARRAY_LOOKUPS_ARE_UNSUPPORTED

=back

.SH "SEE ALSO"
.BR regex (7)
 -->

  </article>

<!--
Local Variables:
mode: sgml
fill-column:80
End:
-->
